<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="referrer" content="origin" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <title>python之路——进程 - Eva_J - 博客园</title>
    <meta property="og:description" content="阅读目录 理论知识 操作系统背景知识 什么是进程 进程调度 进程的并发与并行 同步\异步\阻塞\非阻塞 进程的创建与结束 在python程序中的进程操作 multiprocess模块 进程的创建和mu" />
    <link type="text/css" rel="stylesheet" href="/bundles/blog-common.css?v=KOZafwuaDasEedEenI5aTy8aXH0epbm6VUJ0v3vsT_Q1"/>
<link id="MainCss" type="text/css" rel="stylesheet" href="/skins/LoveIsIntheAir/bundle-LoveIsIntheAir.css?v=1a1njKMb9NXq0SiMQC1DxNR7neAOH_-_T7CqiC-KPw41"/>
<link type="text/css" rel="stylesheet" href="/blog/customcss/250832.css?v=sgnWqV5WAgR4lMmYSWvpJe19YwI%3d"/>
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/LoveIsIntheAir/bundle-LoveIsIntheAir-mobile.css?v=2vKssTQro2c1xn1VJpQlerpUCrPsZu0FDfkhm7xMpkY1"/>
    <link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/Eva-J/rss"/>
    <link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/Eva-J/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/Eva-J/wlwmanifest.xml"/>
    <script src="//common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script>var currentBlogId=250832;var currentBlogApp='Eva-J',cb_enable_mathjax=false;var isLogined=false;</script>
    <script src="/bundles/blog-common.js?v=smtcUT5dhdu_5eEO8CKHYoVc7DPLgEBGzp6zKkstlzg1" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>

<!--PageBeginHtml Block Begin-->
<h2 style="line-height: 1.5em; float: left; text-align: right; color: #816d65; position: absolute; top: 110px; left: 110px; background: #d2eef4">程序媛</h2>
<!--PageBeginHtml Block End-->

<!--done-->
<center>
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a id="lnkBlogLogo" href="https://www.cnblogs.com/Eva-J/"><img id="blogLogo" src="/Skins/LoveIsIntheAir/images/logo.gif" alt="" /></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="https://www.cnblogs.com/Eva-J/">Eva_J</a></h1>
<h2></h2>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
	<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">博客园</a></li>
	<li><a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/Eva-J/">首页</a></li>
	<li><a id="blog_nav_newpost" class="menu" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
	<li><a id="blog_nav_contact" accesskey="9" class="menu" rel="nofollow" href="https://msg.cnblogs.com/send/Eva_J">联系</a></li>
	<li><a id="blog_nav_admin" class="menu" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
	<li><a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/Eva-J/rss">订阅</a>
	<a id="blog_nav_rss_image" class="aHeaderXML" href="https://www.cnblogs.com/Eva-J/rss"><img src="//www.cnblogs.com/images/xml.gif" alt="订阅" /></a></li>
</ul>
		<div class="blogStats">
			
			<div id="blog_stats">
<!--done-->
随笔- 33&nbsp;
文章- 127&nbsp;
评论- 280&nbsp;
</div>
			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div class="clear"></div>
	<div id="topicList">
		
        <div id="post_detail">
<!--done-->
<div id="topics">
	<div class = "post">
		<h1 class = "postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/Eva-J/articles/8253549.html">python之路——进程</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body"><h1>阅读目录</h1>
<div id="cnblogs_post_body"><a name="_labelTop"></a>
<ul>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label1">理论知识</a>
<ul>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label2">操作系统背景知识</a></li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label3">什么是进程</a></li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label4">进程调度</a></li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label5">进程的并发与并行</a></li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label6">同步\异步\阻塞\非阻塞</a></li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label7">进程的创建与结束</a></li>
</ul>
</li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label8">在python程序中的进程操作</a>
<ul>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label19">multiprocess模块</a></li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label10">进程的创建和multiprocess.Process</a></li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label11">进程同步控制 &mdash;&mdash; 锁&nbsp;<br /></a></li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label12">进程间通信 &mdash;&mdash; 队列</a></li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label13">进程间的数据共享 &mdash;&mdash;&nbsp;multiprocess.Manager</a></li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label14">进程池和multiprocess.Pool</a></li>



















</ul>



















</li>



















</ul>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label1"></a></div>
<h1>理论知识</h1>
<h2>操作系统背景知识</h2>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label2"></a></div>
<p><strong>顾名思义，进程即正在执行的一个过程。进程是对正在运行程序的一个抽象。</strong></p>
<p><strong>进程的概念起源于操作系统，是操作系统最核心的概念，也是操作系统提供的最古老也是最重要的抽象概念之一。操作系统的其他所有内容都是围绕进程的概念展开的。</strong></p>
<p><strong>所以想要真正了解进程，必须事先了解操作系统，<a href="http://www.cnblogs.com/Eva-J/articles/8253521.html" target="_blank">点击进入</a>&nbsp; &nbsp;&nbsp;</strong></p>
<p>PS：即使可以利用的cpu只有一个（早期的计算机确实如此），也能保证支持（伪）并发的能力。将一个单独的cpu变成多个虚拟的cpu（多道技术：时间多路复用和空间多路复用+硬件上支持隔离），没有进程的抽象，现代计算机将不复存在。</p>
<p><strong>必备的理论基础：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">一 操作系统的作用：</span>
    1<span style="color: #000000;">：隐藏丑陋复杂的硬件接口，提供良好的抽象接口
    </span>2<span style="color: #000000;">：管理、调度进程，并且将多个进程对硬件的竞争变得有序

</span><span style="color: #008000;">#</span><span style="color: #008000;">二 多道技术：</span>
    1<span style="color: #000000;">.产生背景：针对单核，实现并发
    ps：
    现在的主机一般是多核，那么每个核都会利用多道技术
    有4个cpu，运行于cpu1的某个程序遇到io阻塞，会等到io结束再重新调度，会被调度到4个
    cpu中的任意一个，具体由操作系统调度算法决定。
    
    </span>2<span style="color: #000000;">.空间上的复用：如内存中同时有多道程序
    </span>3<span style="color: #000000;">.时间上的复用：复用一个cpu的时间片
       强调：遇到io切，占用cpu时间过长也切，核心在于切之前将进程的状态保存下来，这样
            才能保证下次切换回来时，能基于上次切走的位置继续运行</span></pre>
</div>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label3"></a></div>
<h2>什么是进程</h2>
<p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank">操作系统</a>结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
<div class="para">狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。</div>
<div class="para">广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192" target="_blank" data-lemmaid="192">操作系统</a>动态执行的<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83" target="_blank">基本单元</a>，在传统的<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank">操作系统</a>中，进程既是基本的<a href="https://baike.baidu.com/item/%E5%88%86%E9%85%8D%E5%8D%95%E5%85%83" target="_blank">分配单元</a>，也是基本的执行单元。</div>
<div class="para">
<div class="cnblogs_code" onclick="cnblogs_code_show('764034dc-2bee-4e80-b05b-c1120edeb455')"><img id="code_img_closed_764034dc-2bee-4e80-b05b-c1120edeb455" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_764034dc-2bee-4e80-b05b-c1120edeb455" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('764034dc-2bee-4e80-b05b-c1120edeb455',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_764034dc-2bee-4e80-b05b-c1120edeb455" class="cnblogs_code_hide">
<pre><span style="color: #000000;">第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。
第二，进程是一个&ldquo;执行中的程序&rdquo;。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。[</span>3<span style="color: #000000;">] 
进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。</span></pre>
</div>
<span class="cnblogs_code_collapse">进程的概念</span></div>
</div>
<div class="para">
<div class="cnblogs_code" onclick="cnblogs_code_show('95dedc7a-44d5-4dde-8a2b-f49db47e59af')"><img id="code_img_closed_95dedc7a-44d5-4dde-8a2b-f49db47e59af" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_95dedc7a-44d5-4dde-8a2b-f49db47e59af" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('95dedc7a-44d5-4dde-8a2b-f49db47e59af',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_95dedc7a-44d5-4dde-8a2b-f49db47e59af" class="cnblogs_code_hide">
<pre><span style="color: #000000;">从理论角度看，是对正在运行的程序过程的抽象；
从实现角度看，是一种数据结构，目的在于清晰地刻画动态系统的内在规律，有效管理和调度进入计算机系统主存储器运行的程序。</span></pre>
</div>
<span class="cnblogs_code_collapse">操作系统引入进程的概念的原因</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('95ff71bd-bbe9-4972-a9ec-c7db6ae53893')"><img id="code_img_closed_95ff71bd-bbe9-4972-a9ec-c7db6ae53893" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_95ff71bd-bbe9-4972-a9ec-c7db6ae53893" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('95ff71bd-bbe9-4972-a9ec-c7db6ae53893',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_95ff71bd-bbe9-4972-a9ec-c7db6ae53893" class="cnblogs_code_hide">
<pre><span style="color: #000000;">动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。
并发性：任何进程都可以同其他进程一起并发执行
独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；
异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进
结构特征：进程由程序、数据和进程控制块三部分组成。
多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。</span></pre>
</div>
<span class="cnblogs_code_collapse">进程的特征</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('415fb02a-730a-48cb-9bcf-62d8b286ac77')"><img id="code_img_closed_415fb02a-730a-48cb-9bcf-62d8b286ac77" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_415fb02a-730a-48cb-9bcf-62d8b286ac77" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('415fb02a-730a-48cb-9bcf-62d8b286ac77',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_415fb02a-730a-48cb-9bcf-62d8b286ac77" class="cnblogs_code_hide">
<pre><span style="color: #000000;">程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。
而进程是程序在处理机上的一次执行过程，它是一个动态的概念。
程序可以作为一种软件资料长期存在，而进程是有一定生命期的。
程序是永久的，进程是暂时的。</span></pre>
</div>
<span class="cnblogs_code_collapse">进程与程序中的区别</span></div>
<p><strong>注意：同一个程序执行两次，就会在操作系统中出现两个进程，所以我们可以同时运行一个软件，分别做不同的事情也不会混乱。</strong></p>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label4"></a></div>
<h2>进程调度</h2>
<p>要想多个进程交替运行，操作系统必须对这些进程进行调度，这个调度也不是随即进行的，而是需要遵循一定的法则，由此就有了进程的调度算法。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('2f08d698-a87d-4629-9287-44976e66da81')"><img id="code_img_closed_2f08d698-a87d-4629-9287-44976e66da81" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_2f08d698-a87d-4629-9287-44976e66da81" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('2f08d698-a87d-4629-9287-44976e66da81',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_2f08d698-a87d-4629-9287-44976e66da81" class="cnblogs_code_hide">
<pre>先来先服务（FCFS）调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。FCFS算法比较有利于长作业（进程），而不利于短作业（进程）。由此可知，本算法适合于CPU繁忙型作业，而不利于I/O繁忙型的作业（进程）。</pre>
</div>
<span class="cnblogs_code_collapse">先来先服务调度算法</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('6aff43dd-e7ad-46ba-9d6f-f31c6a4f309f')"><img id="code_img_closed_6aff43dd-e7ad-46ba-9d6f-f31c6a4f309f" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_6aff43dd-e7ad-46ba-9d6f-f31c6a4f309f" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('6aff43dd-e7ad-46ba-9d6f-f31c6a4f309f',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_6aff43dd-e7ad-46ba-9d6f-f31c6a4f309f" class="cnblogs_code_hide">
<pre>短作业（进程）优先调度算法（SJ/PF）是指对短作业或短进程优先调度的算法，该算法既可用于作业调度，也可用于进程调度。但其对长作业不利；不能保证紧迫性作业（进程）被及时处理；作业的长短只是被估算出来的。</pre>
</div>
<span class="cnblogs_code_collapse">短作业优先调度算法</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('f94f0589-8d79-4d27-8e88-78019a8dadc2')"><img id="code_img_closed_f94f0589-8d79-4d27-8e88-78019a8dadc2" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_f94f0589-8d79-4d27-8e88-78019a8dadc2" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('f94f0589-8d79-4d27-8e88-78019a8dadc2',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_f94f0589-8d79-4d27-8e88-78019a8dadc2" class="cnblogs_code_hide">
<pre><span style="color: #000000;">      时间片轮转(Round Robin，RR)法的基本思路是让每个进程在就绪队列中的等待时间与享受服务的时间成比例。在时间片轮转法中，需要将CPU的处理时间分成固定大小的时间片，例如，几十毫秒至几百毫秒。如果一个进程在被调度选中之后用完了系统规定的时间片，但又未完成要求的任务，则它自行释放自己所占有的CPU而排到就绪队列的末尾，等待下一次调度。同时，进程调度程序又去调度当前就绪队列中的第一个进程。
      显然，轮转法只能用来调度分配一些可以抢占的资源。这些可以抢占的资源可以随时被剥夺，而且可以将它们再分配给别的进程。CPU是可抢占资源的一种。但打印机等资源是不可抢占的。由于作业调度是对除了CPU之外的所有系统硬件资源的分配，其中包含有不可抢占资源，所以作业调度不使用轮转法。
在轮转法中，时间片长度的选取非常重要。首先，时间片长度的选择会直接影响到系统的开销和响应时间。如果时间片长度过短，则调度程序抢占处理机的次数增多。这将使进程上下文切换次数也大大增加，从而加重系统开销。反过来，如果时间片长度选择过长，例如，一个时间片能保证就绪队列中所需执行时间最长的进程能执行完毕，则轮转法变成了先来先服务法。时间片长度的选择是根据系统对响应时间的要求和就绪队列中所允许最大的进程数来确定的。
      在轮转法中，加入到就绪队列的进程有3种情况：
      一种是分给它的时间片用完，但进程还未完成，回到就绪队列的末尾等待下次调度去继续执行。
      另一种情况是分给该进程的时间片并未用完，只是因为请求I</span>/<span style="color: #000000;">O或由于进程的互斥与同步关系而被阻塞。当阻塞解除之后再回到就绪队列。
      第三种情况就是新创建进程进入就绪队列。
      如果对这些进程区别对待，给予不同的优先级和时间片从直观上看，可以进一步改善系统服务质量和效率。例如，我们可把就绪队列按照进程到达就绪队列的类型和进程被阻塞时的阻塞原因分成不同的就绪队列，每个队列按FCFS原则排列，各队列之间的进程享有不同的优先级，但同一队列内优先级相同。这样，当一个进程在执行完它的时间片之后，或从睡眠中被唤醒以及被创建之后，将进入不同的就绪队列。  </span></pre>
</div>
<span class="cnblogs_code_collapse">时间片轮转法</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('a11cb25e-0039-41f4-a5a7-f8fdbb205b04')"><img id="code_img_closed_a11cb25e-0039-41f4-a5a7-f8fdbb205b04" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_a11cb25e-0039-41f4-a5a7-f8fdbb205b04" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('a11cb25e-0039-41f4-a5a7-f8fdbb205b04',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_a11cb25e-0039-41f4-a5a7-f8fdbb205b04" class="cnblogs_code_hide">
<pre><span style="color: #000000;">前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。
而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。
(</span>1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，&hellip;&hellip;，第i+<span style="color: #000000;">1个队列的时间片要比第i个队列的时间片长一倍。
(</span>2<span style="color: #000000;">) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，&hellip;&hellip;，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。

(</span>3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。</pre>
</div>
<span class="cnblogs_code_collapse">多级反馈队列</span></div>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label5"></a></div>
<h2 class="title-text">进程的并行与并发</h2>
<div>
<p><span style="font-size: 15px;"><strong>并行</strong> :&nbsp;</span>并行是指两者同时执行，比如赛跑，两个人都在不停的往前跑；（资源够用，比如三个线程，四核的CPU ）</p>
<p><span style="font-size: 15px;"><strong>并发</strong> :&nbsp;</span>并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A ，交替使用，目的是提高效率。</p>
<p><span style="font-size: 15px;"><strong>区别</strong>:</span></p>
<p> <strong>并行</strong>是从微观上，也就是在一个精确的时间片刻，有不同的程序在执行，这就要求必须有多个处理器。<br />
<strong>并发</strong>是从宏观上，在一个时间段上可以看出是同时执行的，比如一个服务器同时处理多个session。</p>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label6"></a></div>
<h2>同步异步阻塞非阻塞</h2>
<h3>状态介绍</h3>
<p><img src="https://images2017.cnblogs.com/blog/827651/201801/827651-20180110201327535-1120359184.png" alt="" /></p>
<p>　　在了解其他概念之前，我们首先要了解进程的几个状态。在程序运行的过程中，由于被操作系统的调度算法控制，程序会进入几个状态：就绪，运行和阻塞。</p>
<p>　　（1）就绪(Ready)状态</p>
<p>　　当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。</p>
<p>　　（2）执行/运行（Running）状态当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。</p>
<p>　　（3）阻塞(Blocked)状态正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;<img src="https://images2017.cnblogs.com/blog/827651/201801/827651-20180110204322676-135915799.png" alt="" width="410" height="229" /></p>
<h3>同步和异步</h3>
<p>&nbsp; &nbsp; &nbsp;&nbsp;<code>所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列</code>。要么成功都成功，失败都失败，两个任务的状态可以保持一致。</p>
<div>
<p><code>　　所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了</code>。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，<code>所以它是不可靠的任务序列</code>。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('1d0d0fbc-9f49-469b-83cb-2eb03f589544')"><img id="code_img_closed_1d0d0fbc-9f49-469b-83cb-2eb03f589544" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_1d0d0fbc-9f49-469b-83cb-2eb03f589544" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('1d0d0fbc-9f49-469b-83cb-2eb03f589544',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_1d0d0fbc-9f49-469b-83cb-2eb03f589544" class="cnblogs_code_hide">
<pre><span style="color: #000000;">比如我去银行办理业务，可能会有两种方式：
第一种 ：选择排队等候；
第二种 ：选择取一个小纸条上面有我的号码，等到排到我这一号时由柜台的人通知我轮到我去办理业务了；

第一种：前者(排队等候)就是同步等待消息通知，也就是我要一直在等待银行办理业务情况；

第二种：后者(等待别人通知)就是异步等待消息通知。在异步消息处理中，等待消息通知者(在这个例子中就是等待办理业务的人)往往注册一个回调机制，在所等待的事件被触发时由触发机制(在这里是柜台的人)通过某种机制(在这里是写在小纸条上的号码，喊号)找到等待该事件的人。</span></pre>
</div>
<span class="cnblogs_code_collapse">例子</span></div>
<h3>阻塞与非阻塞</h3>
<p>&nbsp; &nbsp; &nbsp;&nbsp;<code>阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的</code></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('a5654f9b-c056-439c-a48f-97176cc93174')"><img id="code_img_closed_a5654f9b-c056-439c-a48f-97176cc93174" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_a5654f9b-c056-439c-a48f-97176cc93174" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('a5654f9b-c056-439c-a48f-97176cc93174',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_a5654f9b-c056-439c-a48f-97176cc93174" class="cnblogs_code_hide">
<pre><span style="color: #000000;">继续上面的那个例子，不论是排队还是使用号码等待通知，如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的，表现在程序中,也就是该程序一直阻塞在该函数调用处不能继续往下执行。
相反，有的人喜欢在银行办理这些业务的时候一边打打电话发发短信一边等待，这样的状态就是非阻塞的，因为他(等待者)没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。

注意：同步非阻塞形式实际上是效率低下的，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而异步非阻塞形式却没有这样的问题，因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。</span></pre>
</div>
<span class="cnblogs_code_collapse">例子</span></div>
<h3>同步/异步与阻塞/非阻塞</h3>
<div><ol>
<li><strong>同步阻塞形式</strong></li>
</ol>
<p>　　效率最低。拿上面的例子来说，就是你专心排队，什么别的事都不做。</p>
<ol start="2">
<li><strong>异步阻塞形式</strong></li>
</ol>
<p>　　如果在银行等待办理业务的人<code>采用的是异步的方式去等待消息被触发（通知）</code>，也就是领了一张小纸条，假如在这段时间里他不能离开银行做其它的事情，那么很显然，这个人被阻塞在了这个等待的操作上面；</p>
<p><strong><code>　　异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</code></strong></p>
<ol start="3">
<li><strong>同步非阻塞形式</strong></li>
</ol>
<p>　　实际上是效率低下的。</p>
<p>　　想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，<code>这个程序需要在这两种不同的行为之间来回的切换</code>，效率可想而知是低下的。</p>
<ol start="4">
<li><strong>异步非阻塞形式</strong></li>
</ol>
<p>　　效率更高，</p>
<p>　　因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，<code>程序没有在两种不同的操作中来回切换</code>。</p>
<p>　　比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。</p>
<p>　　</p>
<p>很多人会把同步和阻塞混淆，是<code>因为很多时候同步操作会以阻塞的形式表现出来</code>，同样的，很多人也会把异步和非阻塞混淆，<code>因为异步操作一般都不会在真正的IO操作处被阻塞</code>。</p>
</div>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label7"></a></div>
<h2>进程的创建与结束</h2>
<h3>进程的创建</h3>
<p>　　但凡是硬件，都需要有操作系统去管理，只要有操作系统，就有进程的概念，就需要有创建进程的方式，一些操作系统只为一个应用程序设计，比如微波炉中的控制器，一旦启动微波炉，所有的进程都已经存在。</p>
<p>　　而对于通用系统（跑很多应用程序），需要有系统运行过程中创建或撤销进程的能力，主要分为4中形式创建新的进程：</p>
<p>　　1. 系统初始化（查看进程linux中用ps命令，windows中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web页面、新闻、打印）</p>
<p>　　2. 一个进程在运行过程中开启了子进程（如nginx开启多进程，os.fork,subprocess.Popen等）</p>
<p>　　3. 用户的交互式请求，而创建一个新进程（如用户双击暴风影音）</p>
<p>　　4. 一个批处理作业的初始化（只在大型机的批处理系统中应用）</p>
<p>　　无论哪一种，新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的。　　</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('139413bd-2e81-485f-8568-725b8687b518')"><img id="code_img_closed_139413bd-2e81-485f-8568-725b8687b518" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_139413bd-2e81-485f-8568-725b8687b518" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('139413bd-2e81-485f-8568-725b8687b518',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_139413bd-2e81-485f-8568-725b8687b518" class="cnblogs_code_hide">
<pre>1<span style="color: #000000;">. 在UNIX中该系统调用是：fork，fork会创建一个与父进程一模一样的副本，二者有相同的存储映像、同样的环境字符串和同样的打开文件（在shell解释器进程中，执行一个命令就会创建一个子进程）

　　</span>2<span style="color: #000000;">. 在windows中该系统调用是：CreateProcess，CreateProcess既处理进程的创建，也负责把正确的程序装入新进程。

　　关于创建子进程，UNIX和windows

　　</span>1<span style="color: #000000;">.相同的是：进程创建后，父进程和子进程有各自不同的地址空间（多道技术要求物理层面实现进程之间内存的隔离），任何一个进程的在其地址空间中的修改都不会影响到另外一个进程。

　　</span>2.不同的是：在UNIX中，子进程的初始地址空间是父进程的一个副本，提示：子进程和父进程是可以有只读的共享内存区的。但是对于windows系统来说，从一开始父进程与子进程的地址空间就是不同的。</pre>
</div>
<span class="cnblogs_code_collapse">创建进程</span></div>
<h3>进程的结束</h3>
<p>　　1. 正常退出（自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用exit，在windows中用ExitProcess）</p>
<p>　　2. 出错退出（自愿，python a.py中a.py不存在）</p>
<p>　　3. 严重错误（非自愿，执行非法指令，如引用不存在的内存，1/0等，可以捕捉异常，try...except...）</p>
<p>　　4. 被其他进程杀死（非自愿，如kill -9）</p>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label8"></a></div>
<h1>在python程序中的进程操作</h1>
<p>　　之前我们已经了解了很多进程相关的理论知识，了解进程是什么应该不再困难了，刚刚我们已经了解了，运行中的程序就是一个进程。所有的进程都是通过它的父进程来创建的。因此，运行起来的python程序也是一个进程，那么我们也可以在程序中再创建进程。多个进程可以实现并发效果，也就是说，当我们的程序中存在多个进程的时候，在某些时候，就会让程序的执行速度变快。以我们之前所学的知识，并不能实现创建进程这个功能，所以我们就需要借助python中强大的模块。</p>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label9"></a></div>
<h2>multiprocess模块</h2>
<p>&nbsp; &nbsp; &nbsp; 仔细说来，multiprocess不是一个模块而是python中一个操作、管理进程的包。 之所以叫multi是取自multiple的多功能的意思,在这个包中几乎包含了和进程有关的所有子模块。由于提供的子模块非常多，为了方便大家归类记忆，我将这部分大致分为四个部分：创建进程部分，进程同步部分，进程池部分，进程之间数据共享。</p>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label10"></a></div>
<h2>multiprocess.process模块</h2>
<h3>process模块介绍</h3>
<p>process模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">Process([group [, target [, name [, args [, kwargs]]]]])，由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）

强调：
</span>1<span style="color: #000000;">. 需要使用关键字的方式来指定参数
</span>2<span style="color: #000000;">. args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号

参数介绍：
</span>1<span style="color: #000000;"> group参数未使用，值始终为None
</span>2<span style="color: #000000;"> target表示调用对象，即子进程要执行的任务
</span>3 args表示调用对象的位置参数元组，args=(1,2,<span style="color: #800000;">'</span><span style="color: #800000;">egon</span><span style="color: #800000;">'</span><span style="color: #000000;">,)
</span>4 kwargs表示调用对象的字典,kwargs={<span style="color: #800000;">'</span><span style="color: #800000;">name</span><span style="color: #800000;">'</span>:<span style="color: #800000;">'</span><span style="color: #800000;">egon</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">age</span><span style="color: #800000;">'</span>:18<span style="color: #000000;">}
</span>5 name为子进程的名称</pre>
</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('1cb4b589-a5e3-43f2-9311-d867d7d74ce4')"><img id="code_img_closed_1cb4b589-a5e3-43f2-9311-d867d7d74ce4" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_1cb4b589-a5e3-43f2-9311-d867d7d74ce4" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('1cb4b589-a5e3-43f2-9311-d867d7d74ce4',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_1cb4b589-a5e3-43f2-9311-d867d7d74ce4" class="cnblogs_code_hide">
<pre><span style="color: #008080;">1</span> <span style="color: #000000;">p.start()：启动进程，并调用该子进程中的p.run() 
</span><span style="color: #008080;">2</span> <span style="color: #000000;">p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法  
</span><span style="color: #008080;">3</span> <span style="color: #000000;">p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁
</span><span style="color: #008080;">4</span> <span style="color: #000000;">p.is_alive():如果p仍然运行，返回True
</span><span style="color: #008080;">5</span> p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程  </pre>
</div>
<span class="cnblogs_code_collapse">方法介绍</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('4dfdd10a-bc1e-4077-a501-ad810f62d163')"><img id="code_img_closed_4dfdd10a-bc1e-4077-a501-ad810f62d163" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_4dfdd10a-bc1e-4077-a501-ad810f62d163" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('4dfdd10a-bc1e-4077-a501-ad810f62d163',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_4dfdd10a-bc1e-4077-a501-ad810f62d163" class="cnblogs_code_hide">
<pre><span style="color: #008080;">1</span> <span style="color: #000000;">p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置
</span><span style="color: #008080;">2</span> <span style="color: #000000;">p.name:进程的名称
</span><span style="color: #008080;">3</span> <span style="color: #000000;">p.pid：进程的pid
</span><span style="color: #008080;">4</span> <span style="color: #000000;">p.exitcode:进程在运行时为None、如果为&ndash;N，表示被信号N结束(了解即可)
</span><span style="color: #008080;">5</span> p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）</pre>
</div>
<span class="cnblogs_code_collapse">属性介绍</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('6b179262-caf0-4156-98b1-6bd9d53c4f46')"><img id="code_img_closed_6b179262-caf0-4156-98b1-6bd9d53c4f46" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_6b179262-caf0-4156-98b1-6bd9d53c4f46" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('6b179262-caf0-4156-98b1-6bd9d53c4f46',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_6b179262-caf0-4156-98b1-6bd9d53c4f46" class="cnblogs_code_hide">
<pre>在Windows操作系统中由于没有fork(linux操作系统中创建进程的机制)，在创建子进程的时候会自动 <span style="color: #0000ff;">import</span> 启动它的这个文件，而在 <span style="color: #0000ff;">import</span> 的时候又执行了整个文件。因此如果将process()直接写在文件中就会无限递归创建子进程报错。所以必须把创建子进程的部分使用if <span style="color: #800080;">__name__</span> ==&lsquo;<span style="color: #800080;">__main__</span>&rsquo; 判断保护起来，<span style="color: #0000ff;">import</span> 的时候  ，就不会递归运行了。</pre>
</div>
<span class="cnblogs_code_collapse">在windows中使用process模块的注意事项</span></div>
<p>&nbsp;</p>
<h3>使用process模块创建进程</h3>
<p>在一个python进程中开启子进程，start方法和并发效果。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('9d9aeb36-0c6f-4044-8a0a-c3287928b129')"><img id="code_img_closed_9d9aeb36-0c6f-4044-8a0a-c3287928b129" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_9d9aeb36-0c6f-4044-8a0a-c3287928b129" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('9d9aeb36-0c6f-4044-8a0a-c3287928b129',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_9d9aeb36-0c6f-4044-8a0a-c3287928b129" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> f(name):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">hello</span><span style="color: #800000;">'</span><span style="color: #000000;">, name)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">我是子进程</span><span style="color: #800000;">'</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    p </span>= Process(target=f, args=(<span style="color: #800000;">'</span><span style="color: #800000;">bob</span><span style="color: #800000;">'</span><span style="color: #000000;">,))
    p.start()
    time.sleep(</span>1<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">执行主进程的内容了</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    </span></pre>
</div>
<span class="cnblogs_code_collapse">在python中启动的第一个子进程</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('6179182c-aec0-40e7-a081-78044e91e0fb')"><img id="code_img_closed_6179182c-aec0-40e7-a081-78044e91e0fb" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_6179182c-aec0-40e7-a081-78044e91e0fb" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('6179182c-aec0-40e7-a081-78044e91e0fb',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_6179182c-aec0-40e7-a081-78044e91e0fb" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> f(name):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">hello</span><span style="color: #800000;">'</span><span style="color: #000000;">, name)
    time.sleep(</span>1<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">我是子进程</span><span style="color: #800000;">'</span><span style="color: #000000;">)


</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    p </span>= Process(target=f, args=(<span style="color: #800000;">'</span><span style="color: #800000;">bob</span><span style="color: #800000;">'</span><span style="color: #000000;">,))
    p.start()
    </span><span style="color: #008000;">#</span><span style="color: #008000;">p.join()</span>
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">我是父进程</span><span style="color: #800000;">'</span>)</pre>
</div>
<span class="cnblogs_code_collapse">join方法</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('d03a49d1-0113-46da-b855-61d09f8abd63')"><img id="code_img_closed_d03a49d1-0113-46da-b855-61d09f8abd63" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_d03a49d1-0113-46da-b855-61d09f8abd63" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('d03a49d1-0113-46da-b855-61d09f8abd63',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_d03a49d1-0113-46da-b855-61d09f8abd63" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> os
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> f(x):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">子进程id ：</span><span style="color: #800000;">'</span>,os.getpid(),<span style="color: #800000;">'</span><span style="color: #800000;">父进程id ：</span><span style="color: #800000;">'</span><span style="color: #000000;">,os.getppid())
    </span><span style="color: #0000ff;">return</span> x*<span style="color: #000000;">x

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主进程id ：</span><span style="color: #800000;">'</span><span style="color: #000000;">, os.getpid())
    p_lst </span>=<span style="color: #000000;"> []
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(5<span style="color: #000000;">):
        p </span>= Process(target=f, args=<span style="color: #000000;">(i,))
        p.start()</span></pre>
</div>
<span class="cnblogs_code_collapse">查看主进程和子进程的进程号</span></div>
<p>&nbsp;</p>
<p>进阶，多个进程同时运行（注意，子进程的执行顺序不是根据启动顺序决定的）</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('4c4766c2-561b-4bef-bbdf-e5c06d7819da')"><img id="code_img_closed_4c4766c2-561b-4bef-bbdf-e5c06d7819da" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_4c4766c2-561b-4bef-bbdf-e5c06d7819da" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('4c4766c2-561b-4bef-bbdf-e5c06d7819da',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_4c4766c2-561b-4bef-bbdf-e5c06d7819da" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process


</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> f(name):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">hello</span><span style="color: #800000;">'</span><span style="color: #000000;">, name)
    time.sleep(</span>1<span style="color: #000000;">)


</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    p_lst </span>=<span style="color: #000000;"> []
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(5<span style="color: #000000;">):
        p </span>= Process(target=f, args=(<span style="color: #800000;">'</span><span style="color: #800000;">bob</span><span style="color: #800000;">'</span><span style="color: #000000;">,))
        p.start()
        p_lst.append(p)</span></pre>
</div>
<span class="cnblogs_code_collapse">多个进程同时运行</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('b062396c-c589-47b2-9a6a-041834d599f9')"><img id="code_img_closed_b062396c-c589-47b2-9a6a-041834d599f9" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_b062396c-c589-47b2-9a6a-041834d599f9" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b062396c-c589-47b2-9a6a-041834d599f9',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_b062396c-c589-47b2-9a6a-041834d599f9" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process


</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> f(name):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">hello</span><span style="color: #800000;">'</span><span style="color: #000000;">, name)
    time.sleep(</span>1<span style="color: #000000;">)


</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    p_lst </span>=<span style="color: #000000;"> []
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(5<span style="color: #000000;">):
        p </span>= Process(target=f, args=(<span style="color: #800000;">'</span><span style="color: #800000;">bob</span><span style="color: #800000;">'</span><span style="color: #000000;">,))
        p.start()
        p_lst.append(p)
        p.join()
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> [p.join() for p in p_lst]</span>
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">父进程在执行</span><span style="color: #800000;">'</span>)</pre>
</div>
<span class="cnblogs_code_collapse">多个进程同时运行，再谈join方法(1)</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('e990f7bb-ab2a-4301-87a2-a5f8d49f5b9d')"><img id="code_img_closed_e990f7bb-ab2a-4301-87a2-a5f8d49f5b9d" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_e990f7bb-ab2a-4301-87a2-a5f8d49f5b9d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('e990f7bb-ab2a-4301-87a2-a5f8d49f5b9d',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_e990f7bb-ab2a-4301-87a2-a5f8d49f5b9d" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> f(name):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">hello</span><span style="color: #800000;">'</span><span style="color: #000000;">, name)
    time.sleep(</span>1<span style="color: #000000;">)

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    p_lst </span>=<span style="color: #000000;"> []
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(5<span style="color: #000000;">):
        p </span>= Process(target=f, args=(<span style="color: #800000;">'</span><span style="color: #800000;">bob</span><span style="color: #800000;">'</span><span style="color: #000000;">,))
        p.start()
        p_lst.append(p)
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> [p.join() for p in p_lst]</span>
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">父进程在执行</span><span style="color: #800000;">'</span>)</pre>
</div>
<span class="cnblogs_code_collapse">多个进程同时运行，再谈join方法(2)</span></div>
<p>&nbsp;</p>
<p>除了上面这些开启进程的方法，还有一种以继承Process类的形式开启进程的方式</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('d0febf1e-8874-42b8-be5f-c0b297fe7861')"><img id="code_img_closed_d0febf1e-8874-42b8-be5f-c0b297fe7861" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_d0febf1e-8874-42b8-be5f-c0b297fe7861" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('d0febf1e-8874-42b8-be5f-c0b297fe7861',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_d0febf1e-8874-42b8-be5f-c0b297fe7861" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> os
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process


</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> MyProcess(Process):
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self,name):
        super().</span><span style="color: #800080;">__init__</span><span style="color: #000000;">()
        self.name</span>=<span style="color: #000000;">name
    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> run(self):
        </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(os.getpid())
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s 正在和女主播聊天</span><span style="color: #800000;">'</span> %<span style="color: #000000;">self.name)

p1</span>=MyProcess(<span style="color: #800000;">'</span><span style="color: #800000;">wupeiqi</span><span style="color: #800000;">'</span><span style="color: #000000;">)
p2</span>=MyProcess(<span style="color: #800000;">'</span><span style="color: #800000;">yuanhao</span><span style="color: #800000;">'</span><span style="color: #000000;">)
p3</span>=MyProcess(<span style="color: #800000;">'</span><span style="color: #800000;">nezha</span><span style="color: #800000;">'</span><span style="color: #000000;">)

p1.start() </span><span style="color: #008000;">#</span><span style="color: #008000;">start会自动调用run</span>
<span style="color: #000000;">p2.start()
</span><span style="color: #008000;">#</span><span style="color: #008000;"> p2.run()</span>
<span style="color: #000000;">p3.start()


p1.join()
p2.join()
p3.join()

</span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主线程</span><span style="color: #800000;">'</span>)</pre>
</div>
<span class="cnblogs_code_collapse">通过继承Process类开启进程</span></div>
<p>&nbsp;</p>
<p>进程之间的数据隔离问题</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('dd766d96-d4ad-4195-8d31-958c63ed90ae')"><img id="code_img_closed_dd766d96-d4ad-4195-8d31-958c63ed90ae" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_dd766d96-d4ad-4195-8d31-958c63ed90ae" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('dd766d96-d4ad-4195-8d31-958c63ed90ae',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_dd766d96-d4ad-4195-8d31-958c63ed90ae" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> work():
    </span><span style="color: #0000ff;">global</span><span style="color: #000000;"> n
    n</span>=<span style="color: #000000;">0
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">子进程内: </span><span style="color: #800000;">'</span><span style="color: #000000;">,n)


</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    n </span>= 100<span style="color: #000000;">
    p</span>=Process(target=<span style="color: #000000;">work)
    p.start()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主进程内: </span><span style="color: #800000;">'</span>,n)</pre>
</div>
<span class="cnblogs_code_collapse">进程之间的数据隔离问题</span></div>
<h3>守护进程</h3>
<p>会随着主进程的结束而结束。</p>
<p>主进程创建守护进程</p>
<p>　　其一：守护进程会在主进程代码执行结束后就终止</p>
<p>　　其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children</p>
<p>注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('a6512635-cccd-4ca5-b461-fe335292a840')"><img id="code_img_closed_a6512635-cccd-4ca5-b461-fe335292a840" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_a6512635-cccd-4ca5-b461-fe335292a840" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('a6512635-cccd-4ca5-b461-fe335292a840',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_a6512635-cccd-4ca5-b461-fe335292a840" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> os
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Myprocess(Process):
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self,person):
        super().</span><span style="color: #800080;">__init__</span><span style="color: #000000;">()
        self.person </span>=<span style="color: #000000;"> person
    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> run(self):
        </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(os.getpid(),self.name)
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s正在和女主播聊天</span><span style="color: #800000;">'</span> %<span style="color: #000000;">self.person)


p</span>=Myprocess(<span style="color: #800000;">'</span><span style="color: #800000;">哪吒</span><span style="color: #800000;">'</span><span style="color: #000000;">)
p.daemon</span>=True <span style="color: #008000;">#</span><span style="color: #008000;">一定要在p.start()前设置,设置p为守护进程,禁止p创建子进程,并且父进程代码执行结束,p即终止运行</span>
<span style="color: #000000;">p.start()
time.sleep(</span>10) <span style="color: #008000;">#</span><span style="color: #008000;"> 在sleep时查看进程id对应的进程ps -ef|grep id</span>
<span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主</span><span style="color: #800000;">'</span>)</pre>
</div>
<span class="cnblogs_code_collapse">守护进程的启动</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('383206cd-0374-4f0d-804c-ebb4b50e46b8')"><img id="code_img_closed_383206cd-0374-4f0d-804c-ebb4b50e46b8" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_383206cd-0374-4f0d-804c-ebb4b50e46b8" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('383206cd-0374-4f0d-804c-ebb4b50e46b8',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_383206cd-0374-4f0d-804c-ebb4b50e46b8" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> foo():
    </span><span style="color: #0000ff;">print</span>(123<span style="color: #000000;">)
    time.sleep(</span>1<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">end123</span><span style="color: #800000;">"</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> bar():
    </span><span style="color: #0000ff;">print</span>(456<span style="color: #000000;">)
    time.sleep(</span>3<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">end456</span><span style="color: #800000;">"</span><span style="color: #000000;">)


p1</span>=Process(target=<span style="color: #000000;">foo)
p2</span>=Process(target=<span style="color: #000000;">bar)

p1.daemon</span>=<span style="color: #000000;">True
p1.start()
p2.start()
time.sleep(</span>0.1<span style="color: #000000;">)
</span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">main-------</span><span style="color: #800000;">"</span>)<span style="color: #008000;">#</span><span style="color: #008000;">打印该行则主进程代码结束,则守护进程p1应该被终止.#可能会有p1任务执行的打印信息123,因为主进程打印main----时,p1也执行了,但是随即被终止.</span></pre>
</div>
<span class="cnblogs_code_collapse">主进程代码执行结束守护进程立即结束</span></div>
<h3>socket聊天并发实例</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('7b2b323a-30bc-40d9-9cc4-0ebce3f3080a')"><img id="code_img_closed_7b2b323a-30bc-40d9-9cc4-0ebce3f3080a" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_7b2b323a-30bc-40d9-9cc4-0ebce3f3080a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('7b2b323a-30bc-40d9-9cc4-0ebce3f3080a',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_7b2b323a-30bc-40d9-9cc4-0ebce3f3080a" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> socket <span style="color: #0000ff;">import</span> *
<span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process

server</span>=<span style="color: #000000;">socket(AF_INET,SOCK_STREAM)
server.setsockopt(SOL_SOCKET,SO_REUSEADDR,</span>1<span style="color: #000000;">)
server.bind((</span><span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>,8080<span style="color: #000000;">))
server.listen(</span>5<span style="color: #000000;">)

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> talk(conn,client_addr):
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;">:
            msg</span>=conn.recv(1024<span style="color: #000000;">)
            </span><span style="color: #0000ff;">if</span> <span style="color: #0000ff;">not</span> msg:<span style="color: #0000ff;">break</span><span style="color: #000000;">
            conn.send(msg.upper())
        </span><span style="color: #0000ff;">except</span><span style="color: #000000;"> Exception:
            </span><span style="color: #0000ff;">break</span>

<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span>: <span style="color: #008000;">#</span><span style="color: #008000;">windows下start进程一定要写到这下面</span>
    <span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        conn,client_addr</span>=<span style="color: #000000;">server.accept()
        p</span>=Process(target=talk,args=<span style="color: #000000;">(conn,client_addr))
        p.start()</span></pre>
</div>
<span class="cnblogs_code_collapse">使用多进程实现socket聊天并发-server</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('29fc8276-e584-4407-9382-04a9eb528339')"><img id="code_img_closed_29fc8276-e584-4407-9382-04a9eb528339" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_29fc8276-e584-4407-9382-04a9eb528339" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('29fc8276-e584-4407-9382-04a9eb528339',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_29fc8276-e584-4407-9382-04a9eb528339" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> socket <span style="color: #0000ff;">import</span> *<span style="color: #000000;">

client</span>=<span style="color: #000000;">socket(AF_INET,SOCK_STREAM)
client.connect((</span><span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>,8080<span style="color: #000000;">))


</span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
    msg</span>=input(<span style="color: #800000;">'</span><span style="color: #800000;">&gt;&gt;: </span><span style="color: #800000;">'</span><span style="color: #000000;">).strip()
    </span><span style="color: #0000ff;">if</span> <span style="color: #0000ff;">not</span> msg:<span style="color: #0000ff;">continue</span><span style="color: #000000;">

    client.send(msg.encode(</span><span style="color: #800000;">'</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">'</span><span style="color: #000000;">))
    msg</span>=client.recv(1024<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(msg.decode(<span style="color: #800000;">'</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">'</span>))</pre>
</div>
<span class="cnblogs_code_collapse">client端</span></div>
<h3>多进程中的其他方法</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('3b66125a-1dcd-4632-afec-4208d71c9ad1')"><img id="code_img_closed_3b66125a-1dcd-4632-afec-4208d71c9ad1" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_3b66125a-1dcd-4632-afec-4208d71c9ad1" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('3b66125a-1dcd-4632-afec-4208d71c9ad1',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_3b66125a-1dcd-4632-afec-4208d71c9ad1" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> random

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Myprocess(Process):
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self,person):
        self.name</span>=<span style="color: #000000;">person
        super().</span><span style="color: #800080;">__init__</span><span style="color: #000000;">()

    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> run(self):
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s正在和网红脸聊天</span><span style="color: #800000;">'</span> %<span style="color: #000000;">self.name)
        time.sleep(random.randrange(</span>1,5<span style="color: #000000;">))
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s还在和网红脸聊天</span><span style="color: #800000;">'</span> %<span style="color: #000000;">self.name)


p1</span>=Myprocess(<span style="color: #800000;">'</span><span style="color: #800000;">哪吒</span><span style="color: #800000;">'</span><span style="color: #000000;">)
p1.start()

p1.terminate()</span><span style="color: #008000;">#</span><span style="color: #008000;">关闭进程,不会立即关闭,所以is_alive立刻查看的结果可能还是存活</span>
<span style="color: #0000ff;">print</span>(p1.is_alive()) <span style="color: #008000;">#</span><span style="color: #008000;">结果为True</span>

<span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">开始</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">print</span>(p1.is_alive()) <span style="color: #008000;">#</span><span style="color: #008000;">结果为False</span></pre>
</div>
<span class="cnblogs_code_collapse">进程对象的其他方法:terminate,is_alive</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('21d2cec6-55ec-4996-8f2f-a0798fb43928')"><img id="code_img_closed_21d2cec6-55ec-4996-8f2f-a0798fb43928" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_21d2cec6-55ec-4996-8f2f-a0798fb43928" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('21d2cec6-55ec-4996-8f2f-a0798fb43928',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_21d2cec6-55ec-4996-8f2f-a0798fb43928" class="cnblogs_code_hide">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Myprocess(Process):
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self,person):
</span><span style="color: #008080;"> 3</span>         self.name=person   <span style="color: #008000;">#</span><span style="color: #008000;"> name属性是Process中的属性，标示进程的名字</span>
<span style="color: #008080;"> 4</span>         super().<span style="color: #800080;">__init__</span>() <span style="color: #008000;">#</span><span style="color: #008000;"> 执行父类的初始化方法会覆盖name属性</span>
<span style="color: #008080;"> 5</span>         <span style="color: #008000;">#</span><span style="color: #008000;">self.name = person # 在这里设置就可以修改进程名字了</span>
<span style="color: #008080;"> 6</span>         <span style="color: #008000;">#</span><span style="color: #008000;">self.person = person #如果不想覆盖进程名，就修改属性名称就可以了</span>
<span style="color: #008080;"> 7</span>     <span style="color: #0000ff;">def</span><span style="color: #000000;"> run(self):
</span><span style="color: #008080;"> 8</span>         <span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s正在和网红脸聊天</span><span style="color: #800000;">'</span> %<span style="color: #000000;">self.name)
</span><span style="color: #008080;"> 9</span>         <span style="color: #008000;">#</span><span style="color: #008000;"> print('%s正在和网红脸聊天' %self.person)</span>
<span style="color: #008080;">10</span>         time.sleep(random.randrange(1,5<span style="color: #000000;">))
</span><span style="color: #008080;">11</span>         <span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s正在和网红脸聊天</span><span style="color: #800000;">'</span> %<span style="color: #000000;">self.name)
</span><span style="color: #008080;">12</span>         <span style="color: #008000;">#</span><span style="color: #008000;"> print('%s正在和网红脸聊天' %self.person)</span>
<span style="color: #008080;">13</span> 
<span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span> p1=Myprocess(<span style="color: #800000;">'</span><span style="color: #800000;">哪吒</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #008080;">16</span> <span style="color: #000000;">p1.start()
</span><span style="color: #008080;">17</span> <span style="color: #0000ff;">print</span>(p1.pid)    <span style="color: #008000;">#</span><span style="color: #008000;">可以查看子进程的进程id</span></pre>
</div>
<span class="cnblogs_code_collapse">进程对象的其他属性:pid和name</span></div>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label11"></a></div>
<h2>进程同步(multiprocess.Lock)</h2>
<h3>锁 &mdash;&mdash; multiprocess.Lock</h3>
<p>&nbsp; &nbsp; &nbsp; 通过刚刚的学习，我们千方百计实现了程序的异步，让多个任务可以同时在几个进程中并发处理，他们之间的运行没有顺序，一旦开启也不受我们控制。尽管并发编程让我们能更加充分的利用IO资源，但是也给我们带来了新的问题。</p>
<p>　　当多个进程使用同一份数据资源的时候，就会引发数据安全或顺序混乱问题。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('332245f6-a6cb-4d52-bb3d-433992a7eac6')"><img id="code_img_closed_332245f6-a6cb-4d52-bb3d-433992a7eac6" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_332245f6-a6cb-4d52-bb3d-433992a7eac6" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('332245f6-a6cb-4d52-bb3d-433992a7eac6',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_332245f6-a6cb-4d52-bb3d-433992a7eac6" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> os
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> random
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> work(n):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s: %s is running</span><span style="color: #800000;">'</span> %<span style="color: #000000;">(n,os.getpid()))
    time.sleep(random.random())
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s:%s is done</span><span style="color: #800000;">'</span> %<span style="color: #000000;">(n,os.getpid()))

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(3<span style="color: #000000;">):
        p</span>=Process(target=work,args=<span style="color: #000000;">(i,))
        p.start()</span></pre>
</div>
<span class="cnblogs_code_collapse">多进程抢占输出资源</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('153a1e7f-636c-431a-b3b8-28bee02569f1')"><img id="code_img_closed_153a1e7f-636c-431a-b3b8-28bee02569f1" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_153a1e7f-636c-431a-b3b8-28bee02569f1" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('153a1e7f-636c-431a-b3b8-28bee02569f1',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_153a1e7f-636c-431a-b3b8-28bee02569f1" class="cnblogs_code_hide">
<pre><span style="color: #008000;">#</span><span style="color: #008000;"> 由并发变成了串行,牺牲了运行效率,但避免了竞争</span>
<span style="color: #0000ff;">import</span><span style="color: #000000;"> os
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> random
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process,Lock

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> work(lock,n):
    lock.acquire()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s: %s is running</span><span style="color: #800000;">'</span> %<span style="color: #000000;"> (n, os.getpid()))
    time.sleep(random.random())
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s: %s is done</span><span style="color: #800000;">'</span> %<span style="color: #000000;"> (n, os.getpid()))
    lock.release()
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    lock</span>=<span style="color: #000000;">Lock()
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(3<span style="color: #000000;">):
        p</span>=Process(target=work,args=<span style="color: #000000;">(lock,i))
        p.start()</span></pre>
</div>
<span class="cnblogs_code_collapse">使用锁维护执行顺序</span></div>
<p>　　上面这种情况虽然使用加锁的形式实现了顺序的执行，但是程序又重新变成串行了，这样确实会浪费了时间，却保证了数据的安全。</p>
<p>　　接下来，我们以模拟抢票为例，来看看数据安全的重要性。&nbsp;</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('38bbbf7b-b4e4-472c-b35c-50ebe68fa5db')"><img id="code_img_closed_38bbbf7b-b4e4-472c-b35c-50ebe68fa5db" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_38bbbf7b-b4e4-472c-b35c-50ebe68fa5db" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('38bbbf7b-b4e4-472c-b35c-50ebe68fa5db',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_38bbbf7b-b4e4-472c-b35c-50ebe68fa5db" class="cnblogs_code_hide">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">文件db的内容为：{"count":1}</span><span style="color: #008000;">
#</span><span style="color: #008000;">注意一定要用双引号，不然json无法识别</span><span style="color: #008000;">
#</span><span style="color: #008000;">并发运行，效率高，但竞争写同一文件，数据写入错乱</span>
<span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process,Lock
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time,json,random
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> search():
    dic</span>=json.load(open(<span style="color: #800000;">'</span><span style="color: #800000;">db</span><span style="color: #800000;">'</span><span style="color: #000000;">))
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">\033[43m剩余票数%s\033[0m</span><span style="color: #800000;">'</span> %dic[<span style="color: #800000;">'</span><span style="color: #800000;">count</span><span style="color: #800000;">'</span><span style="color: #000000;">])

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> get():
    dic</span>=json.load(open(<span style="color: #800000;">'</span><span style="color: #800000;">db</span><span style="color: #800000;">'</span><span style="color: #000000;">))
    time.sleep(</span>0.1) <span style="color: #008000;">#</span><span style="color: #008000;">模拟读数据的网络延迟</span>
    <span style="color: #0000ff;">if</span> dic[<span style="color: #800000;">'</span><span style="color: #800000;">count</span><span style="color: #800000;">'</span>] &gt;<span style="color: #000000;">0:
        dic[</span><span style="color: #800000;">'</span><span style="color: #800000;">count</span><span style="color: #800000;">'</span>]-=1<span style="color: #000000;">
        time.sleep(</span>0.2) <span style="color: #008000;">#</span><span style="color: #008000;">模拟写数据的网络延迟</span>
        json.dump(dic,open(<span style="color: #800000;">'</span><span style="color: #800000;">db</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">w</span><span style="color: #800000;">'</span><span style="color: #000000;">))
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">\033[43m购票成功\033[0m</span><span style="color: #800000;">'</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> task():
    search()
    get()

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(100): <span style="color: #008000;">#</span><span style="color: #008000;">模拟并发100个客户端抢票</span>
        p=Process(target=<span style="color: #000000;">task)
        p.start()</span></pre>
</div>
<span class="cnblogs_code_collapse">多进程同时抢购余票</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('33e22e1d-e906-4ad9-bf48-32e85fa5fa7c')"><img id="code_img_closed_33e22e1d-e906-4ad9-bf48-32e85fa5fa7c" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_33e22e1d-e906-4ad9-bf48-32e85fa5fa7c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('33e22e1d-e906-4ad9-bf48-32e85fa5fa7c',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_33e22e1d-e906-4ad9-bf48-32e85fa5fa7c" class="cnblogs_code_hide">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">文件db的内容为：{"count":5}</span><span style="color: #008000;">
#</span><span style="color: #008000;">注意一定要用双引号，不然json无法识别</span><span style="color: #008000;">
#</span><span style="color: #008000;">并发运行，效率高，但竞争写同一文件，数据写入错乱</span>
<span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process,Lock
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time,json,random
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> search():
    dic</span>=json.load(open(<span style="color: #800000;">'</span><span style="color: #800000;">db</span><span style="color: #800000;">'</span><span style="color: #000000;">))
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">\033[43m剩余票数%s\033[0m</span><span style="color: #800000;">'</span> %dic[<span style="color: #800000;">'</span><span style="color: #800000;">count</span><span style="color: #800000;">'</span><span style="color: #000000;">])

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> get():
    dic</span>=json.load(open(<span style="color: #800000;">'</span><span style="color: #800000;">db</span><span style="color: #800000;">'</span><span style="color: #000000;">))
    time.sleep(random.random()) </span><span style="color: #008000;">#</span><span style="color: #008000;">模拟读数据的网络延迟</span>
    <span style="color: #0000ff;">if</span> dic[<span style="color: #800000;">'</span><span style="color: #800000;">count</span><span style="color: #800000;">'</span>] &gt;<span style="color: #000000;">0:
        dic[</span><span style="color: #800000;">'</span><span style="color: #800000;">count</span><span style="color: #800000;">'</span>]-=1<span style="color: #000000;">
        time.sleep(random.random()) </span><span style="color: #008000;">#</span><span style="color: #008000;">模拟写数据的网络延迟</span>
        json.dump(dic,open(<span style="color: #800000;">'</span><span style="color: #800000;">db</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">w</span><span style="color: #800000;">'</span><span style="color: #000000;">))
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">\033[32m购票成功\033[0m</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">:
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">\033[31m购票失败\033[0m</span><span style="color: #800000;">'</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> task(lock):
    search()
    lock.acquire()
    get()
    lock.release()

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    lock </span>=<span style="color: #000000;"> Lock()
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(100): <span style="color: #008000;">#</span><span style="color: #008000;">模拟并发100个客户端抢票</span>
        p=Process(target=task,args=<span style="color: #000000;">(lock,))
        p.start()</span></pre>
</div>
<span class="cnblogs_code_collapse">使用锁来保证数据安全</span></div>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。</span>
<span style="color: #000000;">虽然可以用文件共享数据实现进程间通信，但问题是：
</span>1<span style="color: #000000;">.效率低（共享数据基于文件，而文件是硬盘上的数据）
</span>2<span style="color: #000000;">.需要自己加锁处理

</span><span style="color: #008000;">#</span><span style="color: #008000;">因此我们最好找寻一种解决方案能够兼顾：1、效率高（多个进程共享一块内存的数据）2、帮我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。</span>
<span style="color: #000000;">队列和管道都是将数据存放于内存中
队列又是基于（管道</span>+<span style="color: #000000;">锁）实现的，可以让我们从复杂的锁问题中解脱出来，
我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。</span>&nbsp;</pre>
</div>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label12"></a></div>
<h2>进程间通信&mdash;&mdash;队列（multiprocess.Queue）</h2>
<h3>进程间通信</h3>
<p><strong>IPC</strong>(Inter-Process Communication)</p>
<h3>队列&nbsp;</h3>
<h4>概念介绍</h4>
<p>创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">Queue([maxsize]) 
创建共享的进程队列。
参数 ：maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。
底层队列使用管道和锁定实现。</span></pre>
</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('271b887e-5a58-4ee5-aea4-4b9a7bf0f8c8')"><img id="code_img_closed_271b887e-5a58-4ee5-aea4-4b9a7bf0f8c8" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_271b887e-5a58-4ee5-aea4-4b9a7bf0f8c8" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('271b887e-5a58-4ee5-aea4-4b9a7bf0f8c8',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_271b887e-5a58-4ee5-aea4-4b9a7bf0f8c8" class="cnblogs_code_hide">
<pre><span style="color: #000000;">Queue([maxsize]) 
创建共享的进程队列。maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。底层队列使用管道和锁定实现。另外，还需要运行支持线程以便队列中的数据传输到底层管道中。 
Queue的实例q具有以下方法：

q.get( [ block [ ,timeout ] ] ) 
返回q中的一个项目。如果q为空，此方法将阻塞，直到队列中有项目可用为止。block用于控制阻塞行为，默认为True. 如果设置为False，将引发Queue.Empty异常（定义在Queue模块中）。timeout是可选超时时间，用在阻塞模式中。如果在制定的时间间隔内没有项目变为可用，将引发Queue.Empty异常。

q.get_nowait( ) 
同q.get(False)方法。

q.put(item [, block [,timeout ] ] ) 
将item放入队列。如果队列已满，此方法将阻塞至有空间可用为止。block控制阻塞行为，默认为True。如果设置为False，将引发Queue.Empty异常（定义在Queue库模块中）。timeout指定在阻塞模式中等待可用空间的时间长短。超时后将引发Queue.Full异常。

q.qsize() 
返回队列中目前项目的正确数量。此函数的结果并不可靠，因为在返回结果和在稍后程序中使用结果之间，队列中可能添加或删除了项目。在某些系统上，此方法可能引发NotImplementedError异常。


q.empty() 
如果调用此方法时 q为空，返回True。如果其他进程或线程正在往队列中添加项目，结果是不可靠的。也就是说，在返回和使用结果之间，队列中可能已经加入新的项目。

q.full() 
如果q已满，返回为True. 由于线程的存在，结果也可能是不可靠的（参考q.empty（）方法）。。</span></pre>
</div>
<span class="cnblogs_code_collapse">方法介绍</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('591ce005-def5-4282-af7a-13b65bf822df')"><img id="code_img_closed_591ce005-def5-4282-af7a-13b65bf822df" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_591ce005-def5-4282-af7a-13b65bf822df" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('591ce005-def5-4282-af7a-13b65bf822df',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_591ce005-def5-4282-af7a-13b65bf822df" class="cnblogs_code_hide">
<pre><span style="color: #000000;">q.close() 
关闭队列，防止队列中加入更多数据。调用此方法时，后台线程将继续写入那些已入队列但尚未写入的数据，但将在此方法完成时马上关闭。如果q被垃圾收集，将自动调用此方法。关闭队列不会在队列使用者中生成任何类型的数据结束信号或异常。例如，如果某个使用者正被阻塞在get（）操作上，关闭生产者中的队列不会导致get（）方法返回错误。

q.cancel_join_thread() 
不会再进程退出时自动连接后台线程。这可以防止join_thread()方法阻塞。

q.join_thread() 
连接队列的后台线程。此方法用于在调用q.close()方法后，等待所有队列项被消耗。默认情况下，此方法由不是q的原始创建者的所有进程调用。调用q.cancel_join_thread()方法可以禁止这种行为。</span></pre>
</div>
<span class="cnblogs_code_collapse">其他方法(了解)</span></div>
<h4>代码实例</h4>
<div class="cnblogs_code" onclick="cnblogs_code_show('a7616d50-0806-4188-9fcf-eeacd0f8bcc4')"><img id="code_img_closed_a7616d50-0806-4188-9fcf-eeacd0f8bcc4" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_a7616d50-0806-4188-9fcf-eeacd0f8bcc4" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('a7616d50-0806-4188-9fcf-eeacd0f8bcc4',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_a7616d50-0806-4188-9fcf-eeacd0f8bcc4" class="cnblogs_code_hide">
<pre><span style="color: #800000;">'''</span><span style="color: #800000;">
multiprocessing模块支持进程间通信的两种主要形式:管道和队列
都是基于消息传递实现的,但是队列接口
</span><span style="color: #800000;">'''</span>

<span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Queue
q</span>=Queue(3<span style="color: #000000;">)

</span><span style="color: #008000;">#</span><span style="color: #008000;">put ,get ,put_nowait,get_nowait,full,empty</span>
q.put(3<span style="color: #000000;">)
q.put(</span>3<span style="color: #000000;">)
q.put(</span>3<span style="color: #000000;">)
</span><span style="color: #008000;">#</span><span style="color: #008000;"> q.put(3)   # 如果队列已经满了，程序就会停在这里，等待数据被别人取走，再将数据放入队列。</span>
           <span style="color: #008000;">#</span><span style="color: #008000;"> 如果队列中的数据一直不被取走，程序就会永远停在这里。</span>
<span style="color: #0000ff;">try</span><span style="color: #000000;">:
    q.put_nowait(</span>3) <span style="color: #008000;">#</span><span style="color: #008000;"> 可以使用put_nowait，如果队列满了不会阻塞，但是会因为队列满了而报错。</span>
<span style="color: #0000ff;">except</span>: <span style="color: #008000;">#</span><span style="color: #008000;"> 因此我们可以用一个try语句来处理这个错误。这样程序不会一直阻塞下去，但是会丢掉这个消息。</span>
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">队列已经满了</span><span style="color: #800000;">'</span><span style="color: #000000;">)

</span><span style="color: #008000;">#</span><span style="color: #008000;"> 因此，我们再放入数据之前，可以先看一下队列的状态，如果已经满了，就不继续put了。</span>
<span style="color: #0000ff;">print</span>(q.full()) <span style="color: #008000;">#</span><span style="color: #008000;">满了</span>

<span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())
</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())
</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())
</span><span style="color: #008000;">#</span><span style="color: #008000;"> print(q.get()) # 同put方法一样，如果队列已经空了，那么继续取就会出现阻塞。</span>
<span style="color: #0000ff;">try</span><span style="color: #000000;">:
    q.get_nowait(</span>3) <span style="color: #008000;">#</span><span style="color: #008000;"> 可以使用get_nowait，如果队列满了不会阻塞，但是会因为没取到值而报错。</span>
<span style="color: #0000ff;">except</span>: <span style="color: #008000;">#</span><span style="color: #008000;"> 因此我们可以用一个try语句来处理这个错误。这样程序不会一直阻塞下去。</span>
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">队列已经空了</span><span style="color: #800000;">'</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">print</span>(q.empty()) <span style="color: #008000;">#</span><span style="color: #008000;">空了</span></pre>
</div>
<span class="cnblogs_code_collapse">单看队列用法</span></div>
<p>上面这个例子还没有加入进程通信，只是先来看看队列为我们提供的方法，以及这些方法的使用和现象。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('1dafbb92-ba2c-449b-9dcf-e902f39ecbb8')"><img id="code_img_closed_1dafbb92-ba2c-449b-9dcf-e902f39ecbb8" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_1dafbb92-ba2c-449b-9dcf-e902f39ecbb8" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('1dafbb92-ba2c-449b-9dcf-e902f39ecbb8',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_1dafbb92-ba2c-449b-9dcf-e902f39ecbb8" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process, Queue

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> f(q):
    q.put([time.asctime(), </span><span style="color: #800000;">'</span><span style="color: #800000;">from Eva</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">hello</span><span style="color: #800000;">'</span>])  <span style="color: #008000;">#</span><span style="color: #008000;">调用主函数中p进程传递过来的进程参数 put函数为向队列中添加一条数据。</span>

<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    q </span>= Queue() <span style="color: #008000;">#</span><span style="color: #008000;">创建一个Queue对象</span>
    p = Process(target=f, args=(q,)) <span style="color: #008000;">#</span><span style="color: #008000;">创建一个进程</span>
<span style="color: #000000;">    p.start()
    </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())
    p.join()</span></pre>
</div>
<span class="cnblogs_code_collapse">子进程发送数据给父进程</span></div>
<p>上面是一个queue的简单应用，使用队列q对象调用get函数来取得队列中最先进入的数据。 接下来看一个稍微复杂一些的例子：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('4c21672c-eb40-4cd3-bf91-b2f6f4e290bb')"><img id="code_img_closed_4c21672c-eb40-4cd3-bf91-b2f6f4e290bb" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_4c21672c-eb40-4cd3-bf91-b2f6f4e290bb" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('4c21672c-eb40-4cd3-bf91-b2f6f4e290bb',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_4c21672c-eb40-4cd3-bf91-b2f6f4e290bb" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> os
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> multiprocessing

</span><span style="color: #008000;">#</span><span style="color: #008000;"> 向queue中输入数据的函数</span>
<span style="color: #0000ff;">def</span><span style="color: #000000;"> inputQ(queue):
    info </span>= str(os.getpid()) + <span style="color: #800000;">'</span><span style="color: #800000;">(put):</span><span style="color: #800000;">'</span> +<span style="color: #000000;"> str(time.asctime())
    queue.put(info)

</span><span style="color: #008000;">#</span><span style="color: #008000;"> 向queue中输出数据的函数</span>
<span style="color: #0000ff;">def</span><span style="color: #000000;"> outputQ(queue):
    info </span>=<span style="color: #000000;"> queue.get()
    </span><span style="color: #0000ff;">print</span> (<span style="color: #800000;">'</span><span style="color: #800000;">%s%s\033[32m%s\033[0m</span><span style="color: #800000;">'</span>%(str(os.getpid()), <span style="color: #800000;">'</span><span style="color: #800000;">(get):</span><span style="color: #800000;">'</span><span style="color: #000000;">,info))

</span><span style="color: #008000;">#</span><span style="color: #008000;"> Main</span>
<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    multiprocessing.freeze_support()
    record1 </span>= []   <span style="color: #008000;">#</span><span style="color: #008000;"> store input processes</span>
    record2 = []   <span style="color: #008000;">#</span><span style="color: #008000;"> store output processes</span>
    queue = multiprocessing.Queue(3<span style="color: #000000;">)

    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 输入进程</span>
    <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10<span style="color: #000000;">):
        process </span>= multiprocessing.Process(target=inputQ,args=<span style="color: #000000;">(queue,))
        process.start()
        record1.append(process)

    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 输出进程</span>
    <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10<span style="color: #000000;">):
        process </span>= multiprocessing.Process(target=outputQ,args=<span style="color: #000000;">(queue,))
        process.start()
        record2.append(process)

    </span><span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span><span style="color: #000000;"> record1:
        p.join()

    </span><span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span><span style="color: #000000;"> record2:
        p.join()</span></pre>
</div>
<span class="cnblogs_code_collapse">批量生产数据放入队列再批量获取结果 x</span></div>
<h4><strong>生产者消费者模型</strong></h4>
<p><em>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。</em></p>
<h5><strong>为什么要使用生产者和消费者模式</strong></h5>
<p><em>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。</em></p>
<h5><strong>什么是生产者消费者模式</strong></h5>
<p><em>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</em></p>
<h5>基于队列实现生产者消费者模型</h5>
<div class="cnblogs_code" onclick="cnblogs_code_show('f9cfe2a4-560f-4f2a-84d1-1fa3c2009721')"><img id="code_img_closed_f9cfe2a4-560f-4f2a-84d1-1fa3c2009721" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_f9cfe2a4-560f-4f2a-84d1-1fa3c2009721" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('f9cfe2a4-560f-4f2a-84d1-1fa3c2009721',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_f9cfe2a4-560f-4f2a-84d1-1fa3c2009721" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process,Queue
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time,random,os
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> consumer(q):
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        res</span>=<span style="color: #000000;">q.get()
        time.sleep(random.randint(</span>1,3<span style="color: #000000;">))
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">\033[45m%s 吃 %s\033[0m</span><span style="color: #800000;">'</span> %<span style="color: #000000;">(os.getpid(),res))

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> producer(q):
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10<span style="color: #000000;">):
        time.sleep(random.randint(</span>1,3<span style="color: #000000;">))
        res</span>=<span style="color: #800000;">'</span><span style="color: #800000;">包子%s</span><span style="color: #800000;">'</span> %<span style="color: #000000;">i
        q.put(res)
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">\033[44m%s 生产了 %s\033[0m</span><span style="color: #800000;">'</span> %<span style="color: #000000;">(os.getpid(),res))

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    q</span>=<span style="color: #000000;">Queue()
    </span><span style="color: #008000;">#</span><span style="color: #008000;">生产者们:即厨师们</span>
    p1=Process(target=producer,args=<span style="color: #000000;">(q,))

    </span><span style="color: #008000;">#</span><span style="color: #008000;">消费者们:即吃货们</span>
    c1=Process(target=consumer,args=<span style="color: #000000;">(q,))

    </span><span style="color: #008000;">#</span><span style="color: #008000;">开始</span>
<span style="color: #000000;">    p1.start()
    c1.start()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主</span><span style="color: #800000;">'</span>)</pre>
</div>
<span class="cnblogs_code_collapse">基于队列实现生产者消费者模型</span></div>
<p>此时的问题是主进程永远不会结束，原因是：生产者p在生产完后就结束了，但是消费者c在取空了q之后，则一直处于死循环中且卡在q.get()这一步。</p>
<p>解决方式无非是让生产者在生产完毕后，往队列中再发一个结束信号，这样消费者在接收到结束信号后就可以break出死循环。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('1fca8d35-3ee2-4f1e-b58d-542a138c939a')"><img id="code_img_closed_1fca8d35-3ee2-4f1e-b58d-542a138c939a" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_1fca8d35-3ee2-4f1e-b58d-542a138c939a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('1fca8d35-3ee2-4f1e-b58d-542a138c939a',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_1fca8d35-3ee2-4f1e-b58d-542a138c939a" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process,Queue
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time,random,os
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> consumer(q):
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        res</span>=<span style="color: #000000;">q.get()
        </span><span style="color: #0000ff;">if</span> res <span style="color: #0000ff;">is</span> None:<span style="color: #0000ff;">break</span> <span style="color: #008000;">#</span><span style="color: #008000;">收到结束信号则结束</span>
        time.sleep(random.randint(1,3<span style="color: #000000;">))
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">\033[45m%s 吃 %s\033[0m</span><span style="color: #800000;">'</span> %<span style="color: #000000;">(os.getpid(),res))

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> producer(q):
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10<span style="color: #000000;">):
        time.sleep(random.randint(</span>1,3<span style="color: #000000;">))
        res</span>=<span style="color: #800000;">'</span><span style="color: #800000;">包子%s</span><span style="color: #800000;">'</span> %<span style="color: #000000;">i
        q.put(res)
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">\033[44m%s 生产了 %s\033[0m</span><span style="color: #800000;">'</span> %<span style="color: #000000;">(os.getpid(),res))
    q.put(None) </span><span style="color: #008000;">#</span><span style="color: #008000;">发送结束信号</span>
<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    q</span>=<span style="color: #000000;">Queue()
    </span><span style="color: #008000;">#</span><span style="color: #008000;">生产者们:即厨师们</span>
    p1=Process(target=producer,args=<span style="color: #000000;">(q,))

    </span><span style="color: #008000;">#</span><span style="color: #008000;">消费者们:即吃货们</span>
    c1=Process(target=consumer,args=<span style="color: #000000;">(q,))

    </span><span style="color: #008000;">#</span><span style="color: #008000;">开始</span>
<span style="color: #000000;">    p1.start()
    c1.start()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主</span><span style="color: #800000;">'</span>)</pre>
</div>
<span class="cnblogs_code_collapse">改良版&mdash;&mdash;生产者消费者模型</span></div>
<p>注意：结束信号None，不一定要由生产者发，主进程里同样可以发，但主进程需要等生产者结束后才应该发送该信号</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('cda78a33-00db-4a5e-8e88-7854c7e84d23')"><img id="code_img_closed_cda78a33-00db-4a5e-8e88-7854c7e84d23" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_cda78a33-00db-4a5e-8e88-7854c7e84d23" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('cda78a33-00db-4a5e-8e88-7854c7e84d23',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_cda78a33-00db-4a5e-8e88-7854c7e84d23" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process,Queue
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time,random,os
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> consumer(q):
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        res</span>=<span style="color: #000000;">q.get()
        </span><span style="color: #0000ff;">if</span> res <span style="color: #0000ff;">is</span> None:<span style="color: #0000ff;">break</span> <span style="color: #008000;">#</span><span style="color: #008000;">收到结束信号则结束</span>
        time.sleep(random.randint(1,3<span style="color: #000000;">))
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">\033[45m%s 吃 %s\033[0m</span><span style="color: #800000;">'</span> %<span style="color: #000000;">(os.getpid(),res))

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> producer(q):
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(2<span style="color: #000000;">):
        time.sleep(random.randint(</span>1,3<span style="color: #000000;">))
        res</span>=<span style="color: #800000;">'</span><span style="color: #800000;">包子%s</span><span style="color: #800000;">'</span> %<span style="color: #000000;">i
        q.put(res)
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">\033[44m%s 生产了 %s\033[0m</span><span style="color: #800000;">'</span> %<span style="color: #000000;">(os.getpid(),res))

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    q</span>=<span style="color: #000000;">Queue()
    </span><span style="color: #008000;">#</span><span style="color: #008000;">生产者们:即厨师们</span>
    p1=Process(target=producer,args=<span style="color: #000000;">(q,))

    </span><span style="color: #008000;">#</span><span style="color: #008000;">消费者们:即吃货们</span>
    c1=Process(target=consumer,args=<span style="color: #000000;">(q,))

    </span><span style="color: #008000;">#</span><span style="color: #008000;">开始</span>
<span style="color: #000000;">    p1.start()
    c1.start()

    p1.join()
    q.put(None) </span><span style="color: #008000;">#</span><span style="color: #008000;">发送结束信号</span>
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主</span><span style="color: #800000;">'</span>)</pre>
</div>
<span class="cnblogs_code_collapse">主进程在生产者生产完毕后发送结束信号None</span></div>
<p>但上述解决方式，在有多个生产者和多个消费者时，我们则需要用一个很low的方式去解决</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('70dc655d-efd3-4739-998b-a98d24bb8bfa')"><img id="code_img_closed_70dc655d-efd3-4739-998b-a98d24bb8bfa" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_70dc655d-efd3-4739-998b-a98d24bb8bfa" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('70dc655d-efd3-4739-998b-a98d24bb8bfa',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_70dc655d-efd3-4739-998b-a98d24bb8bfa" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process,Queue
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time,random,os
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> consumer(q):
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        res</span>=<span style="color: #000000;">q.get()
        </span><span style="color: #0000ff;">if</span> res <span style="color: #0000ff;">is</span> None:<span style="color: #0000ff;">break</span> <span style="color: #008000;">#</span><span style="color: #008000;">收到结束信号则结束</span>
        time.sleep(random.randint(1,3<span style="color: #000000;">))
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">\033[45m%s 吃 %s\033[0m</span><span style="color: #800000;">'</span> %<span style="color: #000000;">(os.getpid(),res))

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> producer(name,q):
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(2<span style="color: #000000;">):
        time.sleep(random.randint(</span>1,3<span style="color: #000000;">))
        res</span>=<span style="color: #800000;">'</span><span style="color: #800000;">%s%s</span><span style="color: #800000;">'</span> %<span style="color: #000000;">(name,i)
        q.put(res)
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">\033[44m%s 生产了 %s\033[0m</span><span style="color: #800000;">'</span> %<span style="color: #000000;">(os.getpid(),res))

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    q</span>=<span style="color: #000000;">Queue()
    </span><span style="color: #008000;">#</span><span style="color: #008000;">生产者们:即厨师们</span>
    p1=Process(target=producer,args=(<span style="color: #800000;">'</span><span style="color: #800000;">包子</span><span style="color: #800000;">'</span><span style="color: #000000;">,q))
    p2</span>=Process(target=producer,args=(<span style="color: #800000;">'</span><span style="color: #800000;">骨头</span><span style="color: #800000;">'</span><span style="color: #000000;">,q))
    p3</span>=Process(target=producer,args=(<span style="color: #800000;">'</span><span style="color: #800000;">泔水</span><span style="color: #800000;">'</span><span style="color: #000000;">,q))

    </span><span style="color: #008000;">#</span><span style="color: #008000;">消费者们:即吃货们</span>
    c1=Process(target=consumer,args=<span style="color: #000000;">(q,))
    c2</span>=Process(target=consumer,args=<span style="color: #000000;">(q,))

    </span><span style="color: #008000;">#</span><span style="color: #008000;">开始</span>
<span style="color: #000000;">    p1.start()
    p2.start()
    p3.start()
    c1.start()

    p1.join() </span><span style="color: #008000;">#</span><span style="color: #008000;">必须保证生产者全部生产完毕,才应该发送结束信号</span>
<span style="color: #000000;">    p2.join()
    p3.join()
    q.put(None) </span><span style="color: #008000;">#</span><span style="color: #008000;">有几个消费者就应该发送几次结束信号None</span>
    q.put(None) <span style="color: #008000;">#</span><span style="color: #008000;">发送结束信号</span>
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主</span><span style="color: #800000;">'</span>)</pre>
</div>
<span class="cnblogs_code_collapse">多个消费者的例子：有几个消费者就需要发送几次结束信号</span></div>
<p>&nbsp;</p>
<p><strong>JoinableQueue([maxsize])</strong>&nbsp;<br />创建可连接的共享进程队列。这就像是一个Queue对象，但队列允许项目的使用者通知生产者项目已经被成功处理。通知进程是使用共享的信号和条件变量来实现的。&nbsp;</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('5b3a5894-ce3b-4ddc-96fb-f58e9c742ae7')"><img id="code_img_closed_5b3a5894-ce3b-4ddc-96fb-f58e9c742ae7" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_5b3a5894-ce3b-4ddc-96fb-f58e9c742ae7" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5b3a5894-ce3b-4ddc-96fb-f58e9c742ae7',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_5b3a5894-ce3b-4ddc-96fb-f58e9c742ae7" class="cnblogs_code_hide">
<pre><span style="color: #000000;">JoinableQueue的实例p除了与Queue对象相同的方法之外，还具有以下方法：

q.task_done() 
使用者使用此方法发出信号，表示q.get()返回的项目已经被处理。如果调用此方法的次数大于从队列中删除的项目数量，将引发ValueError异常。

q.join() 
生产者将使用此方法进行阻塞，直到队列中所有项目均被处理。阻塞将持续到为队列中的每个项目均调用q.task_done()方法为止。 
下面的例子说明如何建立永远运行的进程，使用和处理队列上的项目。生产者将项目放入队列，并等待它们被处理。</span></pre>
</div>
<span class="cnblogs_code_collapse">方法介绍</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('0815cfce-404a-4275-ace4-c15cee35c8e7')"><img id="code_img_closed_0815cfce-404a-4275-ace4-c15cee35c8e7" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_0815cfce-404a-4275-ace4-c15cee35c8e7" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('0815cfce-404a-4275-ace4-c15cee35c8e7',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_0815cfce-404a-4275-ace4-c15cee35c8e7" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process,JoinableQueue
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time,random,os
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> consumer(q):
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        res</span>=<span style="color: #000000;">q.get()
        time.sleep(random.randint(</span>1,3<span style="color: #000000;">))
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">\033[45m%s 吃 %s\033[0m</span><span style="color: #800000;">'</span> %<span style="color: #000000;">(os.getpid(),res))
        q.task_done() </span><span style="color: #008000;">#</span><span style="color: #008000;">向q.join()发送一次信号,证明一个数据已经被取走了</span>

<span style="color: #0000ff;">def</span><span style="color: #000000;"> producer(name,q):
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10<span style="color: #000000;">):
        time.sleep(random.randint(</span>1,3<span style="color: #000000;">))
        res</span>=<span style="color: #800000;">'</span><span style="color: #800000;">%s%s</span><span style="color: #800000;">'</span> %<span style="color: #000000;">(name,i)
        q.put(res)
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">\033[44m%s 生产了 %s\033[0m</span><span style="color: #800000;">'</span> %<span style="color: #000000;">(os.getpid(),res))
    q.join() </span><span style="color: #008000;">#</span><span style="color: #008000;">生产完毕，使用此方法进行阻塞，直到队列中所有项目均被处理。</span>


<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    q</span>=<span style="color: #000000;">JoinableQueue()
    </span><span style="color: #008000;">#</span><span style="color: #008000;">生产者们:即厨师们</span>
    p1=Process(target=producer,args=(<span style="color: #800000;">'</span><span style="color: #800000;">包子</span><span style="color: #800000;">'</span><span style="color: #000000;">,q))
    p2</span>=Process(target=producer,args=(<span style="color: #800000;">'</span><span style="color: #800000;">骨头</span><span style="color: #800000;">'</span><span style="color: #000000;">,q))
    p3</span>=Process(target=producer,args=(<span style="color: #800000;">'</span><span style="color: #800000;">泔水</span><span style="color: #800000;">'</span><span style="color: #000000;">,q))

    </span><span style="color: #008000;">#</span><span style="color: #008000;">消费者们:即吃货们</span>
    c1=Process(target=consumer,args=<span style="color: #000000;">(q,))
    c2</span>=Process(target=consumer,args=<span style="color: #000000;">(q,))
    c1.daemon</span>=<span style="color: #000000;">True
    c2.daemon</span>=<span style="color: #000000;">True

    </span><span style="color: #008000;">#</span><span style="color: #008000;">开始</span>
    p_l=<span style="color: #000000;">[p1,p2,p3,c1,c2]
    </span><span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span><span style="color: #000000;"> p_l:
        p.start()

    p1.join()
    p2.join()
    p3.join()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主</span><span style="color: #800000;">'</span><span style="color: #000000;">) 
    
    </span><span style="color: #008000;">#</span><span style="color: #008000;">主进程等---&gt;p1,p2,p3等----&gt;c1,c2</span>
    <span style="color: #008000;">#</span><span style="color: #008000;">p1,p2,p3结束了,证明c1,c2肯定全都收完了p1,p2,p3发到队列的数据</span>
    <span style="color: #008000;">#</span><span style="color: #008000;">因而c1,c2也没有存在的价值了,不需要继续阻塞在进程中影响主进程了。应该随着主进程的结束而结束,所以设置成守护进程就可以了。</span></pre>
</div>
<span class="cnblogs_code_collapse">JoinableQueue队列实现消费之生产者模型</span></div>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label13"></a></div>
<h2>进程之间的数据共享</h2>
<p>展望未来，基于消息传递的并发编程是大势所趋</p>
<p>即便是使用线程，推荐做法也是将程序设计为大量独立的线程集合，通过消息队列交换数据。</p>
<p>这样极大地减少了对使用锁定和其他同步手段的需求，还可以扩展到分布式系统中。</p>
<p><strong>但进程间应该尽量避免通信，即便需要通信，也应该选择进程安全的工具来避免加锁带来的问题。</strong></p>
<p><em><strong>以后我们会尝试使用数据库来解决现在进程之间的数据共享问题。</strong></em></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('4db9e2f5-8d79-41b4-a349-862de561d7f1')"><img id="code_img_closed_4db9e2f5-8d79-41b4-a349-862de561d7f1" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_4db9e2f5-8d79-41b4-a349-862de561d7f1" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('4db9e2f5-8d79-41b4-a349-862de561d7f1',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_4db9e2f5-8d79-41b4-a349-862de561d7f1" class="cnblogs_code_hide">
<pre><span style="color: #000000;">进程间数据是独立的，可以借助于队列或管道实现通信，二者都是基于消息传递的
虽然进程间数据独立，但可以通过Manager实现数据共享，事实上Manager的功能远不止于此

A manager object returned by Manager() controls a server process which holds Python objects </span><span style="color: #0000ff;">and</span><span style="color: #000000;"> allows other processes to manipulate them using proxies.

A manager returned by Manager() will support types list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value </span><span style="color: #0000ff;">and</span> Array.</pre>
</div>
<span class="cnblogs_code_collapse">Manager模块介绍</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('1eeac7ff-6222-42b9-9d46-70a49ed6a3b1')"><img id="code_img_closed_1eeac7ff-6222-42b9-9d46-70a49ed6a3b1" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_1eeac7ff-6222-42b9-9d46-70a49ed6a3b1" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('1eeac7ff-6222-42b9-9d46-70a49ed6a3b1',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_1eeac7ff-6222-42b9-9d46-70a49ed6a3b1" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Manager,Process,Lock
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> work(d,lock):
    with lock: </span><span style="color: #008000;">#</span><span style="color: #008000;">不加锁而操作共享的数据,肯定会出现数据错乱</span>
        d[<span style="color: #800000;">'</span><span style="color: #800000;">count</span><span style="color: #800000;">'</span>]-=1

<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    lock</span>=<span style="color: #000000;">Lock()
    with Manager() as m:
        dic</span>=m.dict({<span style="color: #800000;">'</span><span style="color: #800000;">count</span><span style="color: #800000;">'</span>:100<span style="color: #000000;">})
        p_l</span>=<span style="color: #000000;">[]
        </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(100<span style="color: #000000;">):
            p</span>=Process(target=work,args=<span style="color: #000000;">(dic,lock))
            p_l.append(p)
            p.start()
        </span><span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span><span style="color: #000000;"> p_l:
            p.join()
        </span><span style="color: #0000ff;">print</span>(dic)</pre>
</div>
<span class="cnblogs_code_collapse">Manager例子</span></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label14"></a></div>
<h2>进程池和multiprocess.Pool模块</h2>
<h3>进程池</h3>
<p>为什么要有进程池?进程池的概念。</p>
<p>在程序实际处理问题过程中，忙时会有成千上万的任务需要被执行，闲时可能只有零星任务。那么在成千上万个任务需要被执行的时候，我们就需要去创建成千上万个进程么？首先，创建进程需要消耗时间，销毁进程也需要消耗时间。第二即便开启了成千上万的进程，操作系统也不能让他们同时执行，这样反而会影响程序的效率。因此我们不能无限制的根据任务开启或者结束进程。那么我们要怎么做呢？</p>
<p>在这里，要给大家介绍一个进程池的概念，定义一个池子，在里面放上固定数量的进程，有需求来了，就拿一个池中的进程来处理任务，等到处理完毕，进程并不关闭，而是将进程再放回进程池中继续等待任务。如果有很多任务需要执行，池中的进程数量不够，任务就要等待之前的进程执行任务完毕归来，拿到空闲进程才能继续执行。也就是说，池中进程的数量是固定的，那么同一时间最多有固定数量的进程在运行。这样不会增加操作系统的调度难度，还节省了开闭进程的时间，也一定程度上能够实现并发效果。</p>
<h3>multiprocess.Pool模块</h3>
<h4>概念介绍</h4>
<div class="cnblogs_code">
<pre>Pool([numprocess  [,initializer [, initargs]]]):创建进程池</pre>
</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('c0a29f2d-17d4-4435-959e-c8b22fbe6e01')"><img id="code_img_closed_c0a29f2d-17d4-4435-959e-c8b22fbe6e01" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_c0a29f2d-17d4-4435-959e-c8b22fbe6e01" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('c0a29f2d-17d4-4435-959e-c8b22fbe6e01',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_c0a29f2d-17d4-4435-959e-c8b22fbe6e01" class="cnblogs_code_hide">
<pre><span style="color: #008080;">1</span> <span style="color: #000000;">numprocess:要创建的进程数，如果省略，将默认使用cpu_count()的值
</span><span style="color: #008080;">2</span> <span style="color: #000000;">initializer：是每个工作进程启动时要执行的可调用对象，默认为None
</span><span style="color: #008080;">3</span> initargs：是要传给initializer的参数组</pre>
</div>
<span class="cnblogs_code_collapse">参数介绍</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('d19681ab-8442-419e-8320-fc793f603d17')"><img id="code_img_closed_d19681ab-8442-419e-8320-fc793f603d17" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_d19681ab-8442-419e-8320-fc793f603d17" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('d19681ab-8442-419e-8320-fc793f603d17',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_d19681ab-8442-419e-8320-fc793f603d17" class="cnblogs_code_hide">
<pre><span style="color: #008080;">1</span> p.apply(func [, args [, kwargs]]):在一个池工作进程中执行func(*args,**<span style="color: #000000;">kwargs),然后返回结果。
</span><span style="color: #008080;">2</span> <span style="color: #800000;">'''</span><span style="color: #800000;">需要强调的是：此操作并不会在所有池工作进程中并执行func函数。如果要通过不同参数并发地执行func函数，必须从不同线程调用p.apply()函数或者使用p.apply_async()</span><span style="color: #800000;">'''</span>
<span style="color: #008080;">3</span> 
<span style="color: #008080;">4</span> p.apply_async(func [, args [, kwargs]]):在一个池工作进程中执行func(*args,**<span style="color: #000000;">kwargs),然后返回结果。
</span><span style="color: #008080;">5</span> <span style="color: #800000;">'''</span><span style="color: #800000;">此方法的结果是AsyncResult类的实例，callback是可调用对象，接收输入参数。当func的结果变为可用时，将理解传递给callback。callback禁止执行任何阻塞操作，否则将接收其他异步操作中的结果。</span><span style="color: #800000;">'''</span>
<span style="color: #008080;">6</span>    
<span style="color: #008080;">7</span> <span style="color: #000000;">p.close():关闭进程池，防止进一步操作。如果所有操作持续挂起，它们将在工作进程终止前完成
</span><span style="color: #008080;">8</span> 
<span style="color: #008080;">9</span> P.jion():等待所有工作进程退出。此方法只能在close（）或teminate()之后调用</pre>
</div>
<span class="cnblogs_code_collapse">主要方法</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('88676341-5a58-4cd2-b22a-954e03ce4862')"><img id="code_img_closed_88676341-5a58-4cd2-b22a-954e03ce4862" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_88676341-5a58-4cd2-b22a-954e03ce4862" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('88676341-5a58-4cd2-b22a-954e03ce4862',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_88676341-5a58-4cd2-b22a-954e03ce4862" class="cnblogs_code_hide">
<pre><span style="color: #008080;">1</span> <span style="color: #000000;">方法apply_async()和map_async（）的返回值是AsyncResul的实例obj。实例具有以下方法
</span><span style="color: #008080;">2</span> <span style="color: #000000;">obj.get():返回结果，如果有必要则等待结果到达。timeout是可选的。如果在指定时间内还没有到达，将引发一场。如果远程操作中引发了异常，它将在调用此方法时再次被引发。
</span><span style="color: #008080;">3</span> <span style="color: #000000;">obj.ready():如果调用完成，返回True
</span><span style="color: #008080;">4</span> <span style="color: #000000;">obj.successful():如果调用完成且没有引发异常，返回True，如果在结果就绪之前调用此方法，引发异常
</span><span style="color: #008080;">5</span> <span style="color: #000000;">obj.wait([timeout]):等待结果变为可用。
</span><span style="color: #008080;">6</span> obj.terminate()：立即终止所有工作进程，同时不执行任何清理或结束任何挂起工作。如果p被垃圾回收，将自动调用此函数</pre>
</div>
<span class="cnblogs_code_collapse">其他方法(了解)</span></div>
<h4>代码实例</h4>
<h5>进程池和多进程效率对比</h5>
<div class="cnblogs_code" onclick="cnblogs_code_show('9ee230ac-2e7a-42de-b2a7-caedd4e6c499')"><img id="code_img_closed_9ee230ac-2e7a-42de-b2a7-caedd4e6c499" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><span class="cnblogs_code_collapse">p.map进程池和进程效率测试</span></div>
<h5>同步和异步</h5>
<div class="cnblogs_code" onclick="cnblogs_code_show('aca1462c-c27e-447b-81bd-7f87b4517587')"><img id="code_img_closed_aca1462c-c27e-447b-81bd-7f87b4517587" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_aca1462c-c27e-447b-81bd-7f87b4517587" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('aca1462c-c27e-447b-81bd-7f87b4517587',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_aca1462c-c27e-447b-81bd-7f87b4517587" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> os,time
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Pool

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> work(n):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s run</span><span style="color: #800000;">'</span> %<span style="color: #000000;">os.getpid())
    time.sleep(</span>3<span style="color: #000000;">)
    </span><span style="color: #0000ff;">return</span> n**2

<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    p</span>=Pool(3) <span style="color: #008000;">#</span><span style="color: #008000;">进程池中从无到有创建三个进程,以后一直是这三个进程在执行任务</span>
    res_l=<span style="color: #000000;">[]
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10<span style="color: #000000;">):
        res</span>=p.apply(work,args=(i,)) <span style="color: #008000;">#</span><span style="color: #008000;"> 同步调用，直到本次任务执行完毕拿到res，等待任务work执行的过程中可能有阻塞也可能没有阻塞</span>
                                    <span style="color: #008000;">#</span><span style="color: #008000;"> 但不管该任务是否存在阻塞，同步调用都会在原地等着</span>
    <span style="color: #0000ff;">print</span>(res_l)</pre>
</div>
<span class="cnblogs_code_collapse">进程池的同步调用</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('234fee5a-3285-4f79-9690-f0c1ce57892c')"><img id="code_img_closed_234fee5a-3285-4f79-9690-f0c1ce57892c" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_234fee5a-3285-4f79-9690-f0c1ce57892c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('234fee5a-3285-4f79-9690-f0c1ce57892c',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_234fee5a-3285-4f79-9690-f0c1ce57892c" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> os
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> random
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Pool

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> work(n):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s run</span><span style="color: #800000;">'</span> %<span style="color: #000000;">os.getpid())
    time.sleep(random.random())
    </span><span style="color: #0000ff;">return</span> n**2

<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    p</span>=Pool(3) <span style="color: #008000;">#</span><span style="color: #008000;">进程池中从无到有创建三个进程,以后一直是这三个进程在执行任务</span>
    res_l=<span style="color: #000000;">[]
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10<span style="color: #000000;">):
        res</span>=p.apply_async(work,args=(i,)) <span style="color: #008000;">#</span><span style="color: #008000;"> 异步运行，根据进程池中有的进程数，每次最多3个子进程在异步执行</span>
                                          <span style="color: #008000;">#</span><span style="color: #008000;"> 返回结果之后，将结果放入列表，归还进程，之后再执行新的任务</span>
                                          <span style="color: #008000;">#</span><span style="color: #008000;"> 需要注意的是，进程池中的三个进程不会同时开启或者同时结束</span>
                                          <span style="color: #008000;">#</span><span style="color: #008000;"> 而是执行完一个就释放一个进程，这个进程就去接收新的任务。  </span>
<span style="color: #000000;">        res_l.append(res)

    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 异步apply_async用法：如果使用异步提交的任务，主进程需要使用jion，等待进程池内任务都处理完，然后可以用get收集结果</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 否则，主进程结束，进程池可能还没来得及执行，也就跟着一起结束了</span>
<span style="color: #000000;">    p.close()
    p.join()
    </span><span style="color: #0000ff;">for</span> res <span style="color: #0000ff;">in</span><span style="color: #000000;"> res_l:
        </span><span style="color: #0000ff;">print</span>(res.get()) <span style="color: #008000;">#</span><span style="color: #008000;">使用get来获取apply_aync的结果,如果是apply,则没有get方法,因为apply是同步执行,立刻获取结果,也根本无需get</span></pre>
</div>
<span class="cnblogs_code_collapse">进程池的异步调用</span></div>
<h5>练习</h5>
<div class="cnblogs_code" onclick="cnblogs_code_show('e9f5cbfc-256d-4a38-b264-778791c34743')"><img id="code_img_closed_e9f5cbfc-256d-4a38-b264-778791c34743" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_e9f5cbfc-256d-4a38-b264-778791c34743" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('e9f5cbfc-256d-4a38-b264-778791c34743',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_e9f5cbfc-256d-4a38-b264-778791c34743" class="cnblogs_code_hide">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">Pool内的进程数默认是cpu核数，假设为4（查看方法os.cpu_count()）</span><span style="color: #008000;">
#</span><span style="color: #008000;">开启6个客户端，会发现2个客户端处于等待状态</span><span style="color: #008000;">
#</span><span style="color: #008000;">在每个进程内查看pid，会发现pid使用为4个，即多个客户端公用4个进程</span>
<span style="color: #0000ff;">from</span> socket <span style="color: #0000ff;">import</span> *
<span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Pool
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> os

server</span>=<span style="color: #000000;">socket(AF_INET,SOCK_STREAM)
server.setsockopt(SOL_SOCKET,SO_REUSEADDR,</span>1<span style="color: #000000;">)
server.bind((</span><span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>,8080<span style="color: #000000;">))
server.listen(</span>5<span style="color: #000000;">)

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> talk(conn):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">进程pid: %s</span><span style="color: #800000;">'</span> %<span style="color: #000000;">os.getpid())
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;">:
            msg</span>=conn.recv(1024<span style="color: #000000;">)
            </span><span style="color: #0000ff;">if</span> <span style="color: #0000ff;">not</span> msg:<span style="color: #0000ff;">break</span><span style="color: #000000;">
            conn.send(msg.upper())
        </span><span style="color: #0000ff;">except</span><span style="color: #000000;"> Exception:
            </span><span style="color: #0000ff;">break</span>

<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    p</span>=Pool(4<span style="color: #000000;">)
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        conn,</span>*_=<span style="color: #000000;">server.accept()
        p.apply_async(talk,args</span>=<span style="color: #000000;">(conn,))
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> p.apply(talk,args=(conn,client_addr)) #同步的话，则同一时间只有一个客户端能访问</span></pre>
</div>
<span class="cnblogs_code_collapse">server：进程池版socket并发聊天</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('406c93e0-6fa3-44ff-854b-55be38b9e6b6')"><img id="code_img_closed_406c93e0-6fa3-44ff-854b-55be38b9e6b6" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_406c93e0-6fa3-44ff-854b-55be38b9e6b6" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('406c93e0-6fa3-44ff-854b-55be38b9e6b6',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_406c93e0-6fa3-44ff-854b-55be38b9e6b6" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> socket <span style="color: #0000ff;">import</span> *<span style="color: #000000;">

client</span>=<span style="color: #000000;">socket(AF_INET,SOCK_STREAM)
client.connect((</span><span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>,8080<span style="color: #000000;">))


</span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
    msg</span>=input(<span style="color: #800000;">'</span><span style="color: #800000;">&gt;&gt;: </span><span style="color: #800000;">'</span><span style="color: #000000;">).strip()
    </span><span style="color: #0000ff;">if</span> <span style="color: #0000ff;">not</span> msg:<span style="color: #0000ff;">continue</span><span style="color: #000000;">

    client.send(msg.encode(</span><span style="color: #800000;">'</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">'</span><span style="color: #000000;">))
    msg</span>=client.recv(1024<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(msg.decode(<span style="color: #800000;">'</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">'</span>))</pre>
</div>
<span class="cnblogs_code_collapse">client</span></div>
<p>发现：并发开启多个客户端，服务端同一时间只有4个不同的pid，只能结束一个客户端，另外一个客户端才会进来.</p>
<h5><strong>回调函数</strong></h5>
<div class="cnblogs_code">
<pre><span style="color: #000000;">需要回调函数的场景：进程池中任何一个任务一旦处理完了，就立即告知主进程：我好了额，你可以处理我的结果了。主进程则调用一个函数去处理该结果，该函数即回调函数

我们可以把耗时间（阻塞）的任务放到进程池中，然后指定回调函数（主进程负责执行），这样主进程在执行回调函数时就省去了I</span>/O的过程，直接拿到的是任务的结果。</pre>
</div>
<p>&nbsp;</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('3cdc865b-a496-4b68-8522-8a62b68461a6')"><img id="code_img_closed_3cdc865b-a496-4b68-8522-8a62b68461a6" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_3cdc865b-a496-4b68-8522-8a62b68461a6" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('3cdc865b-a496-4b68-8522-8a62b68461a6',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_3cdc865b-a496-4b68-8522-8a62b68461a6" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Pool
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> requests
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> json
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> os

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> get_page(url):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">&lt;进程%s&gt; get %s</span><span style="color: #800000;">'</span> %<span style="color: #000000;">(os.getpid(),url))
    respone</span>=<span style="color: #000000;">requests.get(url)
    </span><span style="color: #0000ff;">if</span> respone.status_code == 200<span style="color: #000000;">:
        </span><span style="color: #0000ff;">return</span> {<span style="color: #800000;">'</span><span style="color: #800000;">url</span><span style="color: #800000;">'</span>:url,<span style="color: #800000;">'</span><span style="color: #800000;">text</span><span style="color: #800000;">'</span><span style="color: #000000;">:respone.text}

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> pasrse_page(res):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">&lt;进程%s&gt; parse %s</span><span style="color: #800000;">'</span> %(os.getpid(),res[<span style="color: #800000;">'</span><span style="color: #800000;">url</span><span style="color: #800000;">'</span><span style="color: #000000;">]))
    parse_res</span>=<span style="color: #800000;">'</span><span style="color: #800000;">url:&lt;%s&gt; size:[%s]\n</span><span style="color: #800000;">'</span> %(res[<span style="color: #800000;">'</span><span style="color: #800000;">url</span><span style="color: #800000;">'</span>],len(res[<span style="color: #800000;">'</span><span style="color: #800000;">text</span><span style="color: #800000;">'</span><span style="color: #000000;">]))
    with open(</span><span style="color: #800000;">'</span><span style="color: #800000;">db.txt</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">) as f:
        f.write(parse_res)


</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    urls</span>=<span style="color: #000000;">[
        </span><span style="color: #800000;">'</span><span style="color: #800000;">https://www.baidu.com</span><span style="color: #800000;">'</span><span style="color: #000000;">,
        </span><span style="color: #800000;">'</span><span style="color: #800000;">https://www.python.org</span><span style="color: #800000;">'</span><span style="color: #000000;">,
        </span><span style="color: #800000;">'</span><span style="color: #800000;">https://www.openstack.org</span><span style="color: #800000;">'</span><span style="color: #000000;">,
        </span><span style="color: #800000;">'</span><span style="color: #800000;">https://help.github.com/</span><span style="color: #800000;">'</span><span style="color: #000000;">,
        </span><span style="color: #800000;">'</span><span style="color: #800000;">http://www.sina.com.cn/</span><span style="color: #800000;">'</span><span style="color: #000000;">
    ]

    p</span>=Pool(3<span style="color: #000000;">)
    res_l</span>=<span style="color: #000000;">[]
    </span><span style="color: #0000ff;">for</span> url <span style="color: #0000ff;">in</span><span style="color: #000000;"> urls:
        res</span>=p.apply_async(get_page,args=(url,),callback=<span style="color: #000000;">pasrse_page)
        res_l.append(res)

    p.close()
    p.join()
    </span><span style="color: #0000ff;">print</span>([res.get() <span style="color: #0000ff;">for</span> res <span style="color: #0000ff;">in</span> res_l]) <span style="color: #008000;">#</span><span style="color: #008000;">拿到的是get_page的结果,其实完全没必要拿该结果,该结果已经传给回调函数处理了</span>

<span style="color: #800000;">'''</span><span style="color: #800000;">
打印结果:
&lt;进程3388&gt; get https://www.baidu.com
&lt;进程3389&gt; get https://www.python.org
&lt;进程3390&gt; get https://www.openstack.org
&lt;进程3388&gt; get https://help.github.com/
&lt;进程3387&gt; parse https://www.baidu.com
&lt;进程3389&gt; get http://www.sina.com.cn/
&lt;进程3387&gt; parse https://www.python.org
&lt;进程3387&gt; parse https://help.github.com/
&lt;进程3387&gt; parse http://www.sina.com.cn/
&lt;进程3387&gt; parse https://www.openstack.org
[{'url': 'https://www.baidu.com', 'text': '&lt;!DOCTYPE html&gt;\r\n...',...}]
</span><span style="color: #800000;">'''</span></pre>
</div>
<span class="cnblogs_code_collapse">使用多进程请求多个url来减少网络等待浪费的时间</span></div>
<p>&nbsp;</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('4c1cb18e-2aa6-473e-b47f-10ec19429bf6')"><img id="code_img_closed_4c1cb18e-2aa6-473e-b47f-10ec19429bf6" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_4c1cb18e-2aa6-473e-b47f-10ec19429bf6" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('4c1cb18e-2aa6-473e-b47f-10ec19429bf6',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_4c1cb18e-2aa6-473e-b47f-10ec19429bf6" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> re
</span><span style="color: #0000ff;">from</span> urllib.request <span style="color: #0000ff;">import</span><span style="color: #000000;"> urlopen
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Pool

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> get_page(url,pattern):
    response</span>=urlopen(url).read().decode(<span style="color: #800000;">'</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> pattern,response

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> parse_page(info):
    pattern,page_content</span>=<span style="color: #000000;">info
    res</span>=<span style="color: #000000;">re.findall(pattern,page_content)
    </span><span style="color: #0000ff;">for</span> item <span style="color: #0000ff;">in</span><span style="color: #000000;"> res:
        dic</span>=<span style="color: #000000;">{
            </span><span style="color: #800000;">'</span><span style="color: #800000;">index</span><span style="color: #800000;">'</span><span style="color: #000000;">:item[0].strip(),
            </span><span style="color: #800000;">'</span><span style="color: #800000;">title</span><span style="color: #800000;">'</span>:item[1<span style="color: #000000;">].strip(),
            </span><span style="color: #800000;">'</span><span style="color: #800000;">actor</span><span style="color: #800000;">'</span>:item[2<span style="color: #000000;">].strip(),
            </span><span style="color: #800000;">'</span><span style="color: #800000;">time</span><span style="color: #800000;">'</span>:item[3<span style="color: #000000;">].strip(),
        }
        </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(dic)
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    regex </span>= r<span style="color: #800000;">'</span><span style="color: #800000;">&lt;dd&gt;.*?&lt;.*?class="board-index.*?&gt;(\d+)&lt;/i&gt;.*?title="(.*?)".*?class="movie-item-info".*?&lt;p class="star"&gt;(.*?)&lt;/p&gt;.*?&lt;p class="releasetime"&gt;(.*?)&lt;/p&gt;</span><span style="color: #800000;">'</span><span style="color: #000000;">
    pattern1</span>=<span style="color: #000000;">re.compile(regex,re.S)

    url_dic</span>=<span style="color: #000000;">{
        </span><span style="color: #800000;">'</span><span style="color: #800000;">http://maoyan.com/board/7</span><span style="color: #800000;">'</span><span style="color: #000000;">:pattern1,
    }

    p</span>=<span style="color: #000000;">Pool()
    res_l</span>=<span style="color: #000000;">[]
    </span><span style="color: #0000ff;">for</span> url,pattern <span style="color: #0000ff;">in</span><span style="color: #000000;"> url_dic.items():
        res</span>=p.apply_async(get_page,args=(url,pattern),callback=<span style="color: #000000;">parse_page)
        res_l.append(res)

    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span><span style="color: #000000;"> res_l:
        i.get()</span></pre>
</div>
<span class="cnblogs_code_collapse">爬虫实例</span></div>
<p>&nbsp;</p>
<p><strong>如果在主进程中等待进程池中所有任务都执行完毕后，再统一处理结果，则无需回调函数</strong></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('994e930b-824a-415d-8755-d1efda81b646')"><img id="code_img_closed_994e930b-824a-415d-8755-d1efda81b646" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_994e930b-824a-415d-8755-d1efda81b646" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('994e930b-824a-415d-8755-d1efda81b646',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_994e930b-824a-415d-8755-d1efda81b646" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Pool
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time,random,os

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> work(n):
    time.sleep(</span>1<span style="color: #000000;">)
    </span><span style="color: #0000ff;">return</span> n**2
<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    p</span>=<span style="color: #000000;">Pool()

    res_l</span>=<span style="color: #000000;">[]
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10<span style="color: #000000;">):
        res</span>=p.apply_async(work,args=<span style="color: #000000;">(i,))
        res_l.append(res)

    p.close()
    p.join() </span><span style="color: #008000;">#</span><span style="color: #008000;">等待进程池中所有进程执行完毕</span>
<span style="color: #000000;">
    nums</span>=<span style="color: #000000;">[]
    </span><span style="color: #0000ff;">for</span> res <span style="color: #0000ff;">in</span><span style="color: #000000;"> res_l:
        nums.append(res.get()) </span><span style="color: #008000;">#</span><span style="color: #008000;">拿到所有结果</span>
    <span style="color: #0000ff;">print</span>(nums) <span style="color: #008000;">#</span><span style="color: #008000;">主进程拿到所有的处理结果,可以在主进程中进行统一进行处理</span></pre>
</div>
<span class="cnblogs_code_collapse">无需回调函数</span></div>
<p><a href="https://docs.python.org/dev/library/concurrent.futures.html" target="_blank"><strong>进程池的其他实现方式：https://docs.python.org/dev/library/concurrent.futures.html</strong></a></p>
<pre>参考资料<br />http://www.cnblogs.com/linhaifeng/articles/6817679.html<br />https://www.jianshu.com/p/1200fd49b583<br />https://www.jianshu.com/p/aed6067eeac9<br /><br /><br /></pre>
</div>
</div>
</div>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>


		</div>
		<div class = "postDesc">posted @ <span id="post-date">2018-01-19 08:32</span> <a href='https://www.cnblogs.com/Eva-J/'>Eva_J</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>) &nbsp;<a href="https://i.cnblogs.com/EditArticles.aspx?postid=8253549" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8253549);return false;">收藏</a></div>
	</div>
	<script type="text/javascript">var allowComments=true,cb_blogId=250832,cb_entryId=8253549,cb_blogApp=currentBlogApp,cb_blogUserGuid='4997edaa-857b-e511-9fc1-ac853d9f53cc',cb_entryCreatedDate='2018/1/19 8:32:00';loadViewCount(cb_entryId);var cb_postType=2;var isMarkdown=false;</script>
	
</div><!--end: topics 文章、评论容器-->
</div><a name="!comments"></a><div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id='comment_form' class='commentform'>
<a name='commentform'></a>
<div id='divCommentShow'></div>
<div id='comment_nav'><span id='span_refresh_tips'></span><a href='javascript:void(0);' onclick='return RefreshCommentList();' id='lnk_RefreshComments' runat='server' clientidmode='Static'>刷新评论</a><a href='#' onclick='return RefreshPage();'>刷新页面</a><a href='#top'>返回顶部</a></div>
<div id='comment_form_container'></div>
<div class='ad_text_commentbox' id='ad_text_under_commentbox'></div>
<div id='ad_t2'></div>
<div id='opt_under_post'></div>
<script async='async' src='https://www.googletagservices.com/tag/js/gpt.js'></script>
<script>
  var googletag = googletag || {};
  googletag.cmd = googletag.cmd || [];
</script>
<script>
  googletag.cmd.push(function() {
        googletag.defineSlot('/1090369/C1', [300, 250], 'div-gpt-ad-1546353474406-0').addService(googletag.pubads());
        googletag.defineSlot('/1090369/C2', [468, 60], 'div-gpt-ad-1539008685004-0').addService(googletag.pubads());
        googletag.pubads().enableSingleRequest();
        googletag.enableServices();
  });
</script>
<div id='cnblogs_c1' class='c_ad_block'>
    <div id='div-gpt-ad-1546353474406-0' style='height:250px; width:300px;'></div>
</div>
<div id='under_post_news'></div>
<div id='cnblogs_c2' class='c_ad_block'>
    <div id='div-gpt-ad-1539008685004-0' style='height:60px; width:468px;'></div>
</div>
<div id='under_post_kb'></div>
<div id='HistoryToday' class='c_ad_block'></div>
<script type='text/javascript'>
 if(enablePostBottom()) {
    codeHighlight();
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverT2();
    deliverC1();
    deliverC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);  
}
</script>
</div>

    
	</div><!--end: topicList 文章列表容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="calendar"><div id="blog-calendar" style="display:none"></div><script type="text/javascript">loadBlogDefaultCalendar();</script></div>
			
			<DIV id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div><script type="text/javascript">loadBlogSideColumn();</script>
			</DIV>
			
		</div><!--end: sideBarMain -->
		<div class="clear"></div>
		<div id="footer">
			
<!--done-->
Copyright &copy;2019 Eva_J
		</div><!--end: footer -->
	</div><!--end: sideBar 侧边栏容器 -->
</div><!--end: home 自定义的最大容器 -->
</center>

</body>
</html>
