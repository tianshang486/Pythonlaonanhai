# tcp协议的多人多次通信
    # 和一个人通信说多句话
    # 和一个人聊完再和其他人聊
    # socket() tcp协议的server
    # bind 绑定一个ip和端口
    # listen 监听,代表socket服务的开启
    # accept 等,到有客户端来访问和客户端建立连接
    # send 直接通过连接发送消息,不需要写地址
    # recv 只接收消息
    # connect 客户端/tcp协议的方法,和server端建立连接
    # close 关闭服务/连接
# udp协议的多人通信
    # socket(type=socket.SOCK_DGRAM)
    # sendto 需要写一个对方的地址
    # recvfrom 接收消息和地址
    # close 关闭服务/连接
# 每一句话什么意思?执行到哪儿程序会阻塞?为什么阻塞?什么时候结束阻塞?
    # input()  # 等待,直到用户输入enter键
    # accept 阻塞,有客户端来和我建立完连接之后
    # recv   阻塞,直到收到对方发过来的消息之后
    # recvfrom 阻塞,直到收到对方发过来的消息之后
    # connect 阻塞,直到server端结束了对一个client的服务,开始和当前client建立连接的时候
# 粘包现象
    # 什么粘包?
        # 两条或更多条分开发送的信息连在一起就是粘包现象
    # 发生在发送端 : 发送间隔短,数据小,由于优化机制就合并在一起发送了
    # 发生在接收端 : 接收不及时,所以数据就在接收方的缓存端黏在一起了
    # 粘包发生的本质 : tcp协议的传输是流式传输 数据与数据之间没有边界
    # 怎么解决粘包 : 自定义协议 struct模块
        # 先发送四字节的数据长度       # 先接受4字节 知道数据的长度
        # 再按照长度发送数据           # 再按照长度接收数据