# 进程
# 线程
    # 正常的开发语言 多线程可以利用多核
    # cpython解释器下的多个线程不能利用多核 : 规避了所有io操作的单线程
# 协程
    # 是操作系统不可见的
    # 协程本质就是一条线程 多个任务在一条线程上来回切换
    # 利用协程这个概念实现的内容 : 来规避IO操作,就达到了我们将一条线程中的io操作降到最低的目的

# import time
# def func1():
#     print('start')
#     time.sleep(1)
#     print('end')
#
# def func2():
#     print('start')
#     time.sleep(1)
#     print('end')

# 切换 并 规避io 的两个模块
# gevent =  利用了  greenlet    底层模块完成的切换 + 自动规避io的功能
# asyncio = 利用了  yield    底层语法完成的切换 + 自动规避io的功能
    # tornado 异步的web框架
    # yield from - 更好的实现协程
    # send - 更好的实现协程
    # asyncio模块 基于python原生的协程的概念正式的被成立
    # 特殊的在python中提供协程功能的关键字 : aysnc await

# 进程 数据隔离 数据不安全  操作系统级别  开销非常大  能利用多核
# 线程 数据共享 数据不安全  操作系统级别  开销小      不能利用多核   一些和文件操作相关的io只有操作系统能感知到
# 协程 数据共享 数据安全    用户级别      更小        不能利用多核   协程的所有的切换都基于用户，只有在用户级别能够感知到的io才会用协程模块做切换来规避（socket，请求网页的）

# 用户级别的协程还有什么好处：
    # 减轻了操作系统的负担
    # 一条线程如果开了多个协程，那么给操作系统的印象是线程很忙，这样能多争取一些时间片时间来被CPU执行,程序的效率就提高了

# a = 1
# def func():
#     global a
#     # 切换
#     a += 1
#     # 切换
#
# import dis
# dis.dis(func)
# 对于操作系统 : python代码--> 编译 --> 字节码 --> 解释 --> 二进制010101010010101010
# 二进制 反编译过来的 --> LOAD_GLOBAL

# 4cpu
# 进程 :5个进程
# 线程 :20个
# 协程 :500个
# 5*20*500 = 50000









